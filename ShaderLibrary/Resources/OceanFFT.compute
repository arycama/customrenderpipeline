#include "../Complex.hlsl"
#include "../Math.hlsl"
#include "../Random.hlsl"
#include "../Material.hlsl"

#pragma kernel Dispersion
#pragma kernel FftColumns
#pragma kernel CalculateNormals
#pragma kernel GenerateFilteredMips
#pragma kernel Spectrum

cbuffer InitSpectrumProperties
{
	float4 _OceanScale, SpectrumStart, SpectrumEnd;
	float _OceanGravity, TimeScale, SequenceLength;
};

RWBuffer<float> OceanDispersionWrite;
RWBuffer<float4> OceanSpectrumWrite;
Buffer<float> OceanDispersion;
Buffer<float4> OceanSpectrum;

RWTexture2DArray<float2> HeightResult;
RWTexture2DArray<float4> DisplacementResult, SlopeResult;

static const uint _Resolution = 128;
static const uint Log2Resolution = log2(_Resolution);
static const float HalfResolution = _Resolution * 0.5;

cbuffer OceanData
{
	float scale0;
	float windSpeed0;
	float windAngle0;
	float fetch0;
	float spreadBlend0;
	float swell0;
	float peakEnhancement0;
	float shortWavesFade0;
	float scale1;
	float windSpeed1;
	float windAngle1;
	float fetch1;
	float spreadBlend1;
	float swell1;
	float peakEnhancement1;
	float shortWavesFade1;
};

float PhillipsSpectrum(float2 k, float kLength, float rcpPatchSize)
{
	// Amplitude normalization
	float fftNorm = pow(_Resolution, -0.25);
	float philNorm = exp(1.0) * rcpPatchSize;
	float a = Sq(fftNorm * philNorm);

	float maxWaveHeight = Sq(windSpeed0) / _OceanGravity; // Largest possible waves arising from a continuous wind speed of V
	
	// Eq 40
	float2 windDirection = float2(cos(windAngle0 * TwoPi), sin(windAngle0 * TwoPi));
	float phillips = a * exp(-rcp(Sq(kLength * maxWaveHeight))) / pow(kLength, 4.0) * pow(dot(k, windDirection), 6.0);
	
	// Remove small wavelengths (eq 41)
	phillips *= exp(-Sq(kLength * shortWavesFade0));
	
	phillips = sqrt(phillips);
	
	// Move waves along wind direction
	if (dot(k, windDirection) < 0.0)
		phillips *= -sqrt(1.0 - swell0);

	return phillips;
}

[numthreads(32, 32, 1)]
void Spectrum(uint3 id : SV_DispatchThreadID)
{
	float rcpPatchSize = _OceanScale[id.z];

	float n = id.x - HalfResolution;
	float m = id.y - HalfResolution;
	
	float4 hkt = 0.0;
	float wk = 0.0;
	
	uint index = (id.z * _Resolution + id.y) * _Resolution + id.x;
	
	float nr = length(float2(n, m));
	if ((n || m) && nr >= SpectrumStart[id.z] && nr < SpectrumEnd[id.z])
	{
		float2 k = TwoPi * float2(n, m) * rcpPatchSize;
		float rcpKLength = RcpLength(k);
		float kLength = rcp(rcpKLength);
	
		// Eq 31
		float w2 = _OceanGravity * kLength;
		float w = sqrt(w2);
	
		// Eq 34
		float T = SequenceLength;
		float w0 = TwoPi / T;
		
		// Eq 35
		wk = floor(w / w0) * w0;
		
		// Gaussian random numbers
		float4 xi = GaussianFloat4(index);
		
		hkt.xy = rcp(sqrt(2.0)) * xi.xy * PhillipsSpectrum(k / kLength, kLength, rcpPatchSize);
		hkt.zw = rcp(sqrt(2.0)) * xi.zw * PhillipsSpectrum(-k / kLength, kLength, rcpPatchSize);
	}
	
	OceanDispersionWrite[index] = wk;
	OceanSpectrumWrite[index] = hkt;
}

groupshared float2 _HShared[2][_Resolution];
groupshared float2 _DxShared[2][_Resolution];
groupshared float2 _DzShared[2][_Resolution];
groupshared float2 _SxShared[2][_Resolution];
groupshared float2 _SzShared[2][_Resolution];

void Fft(uint id, inout float2 height, inout float2 dispX, inout float2 dispZ, inout float2 slopeX, inout float2 slopeZ)
{
    // Load entire row or column into scratch array
	_HShared[0][id] = height;
	_DxShared[0][id] = dispX;
	_DzShared[0][id] = dispZ;
	_SxShared[0][id] = slopeX;
	_SzShared[0][id] = slopeZ;

	uint2 textureIndices = uint2(0, 1);
	
	uint2 indices = 0;
	uint passCount = log2(_Resolution);
	for (uint i = 0; i < passCount; i++)
	{
		GroupMemoryBarrierWithGroupSync();

		uint sectionWidth = 2 << i;
		uint halfSectionWidth = sectionWidth / 2;

		uint sectionStartOffset = id & ~(sectionWidth - 1);
		uint halfSectionOffset = id & (halfSectionWidth - 1);
		uint sectionOffset = id & (sectionWidth - 1);

		uint2 indices = sectionStartOffset + halfSectionOffset;
		indices.y += halfSectionWidth;

		if (i == 0)
			indices = reversebits(indices) >> (32 - passCount) & (_Resolution - 1);
		
		float2 weights = cexp(cimg(2.0 * Pi * sectionOffset / sectionWidth));

		height = _HShared[textureIndices.y][id] = cadd(_HShared[textureIndices.x][indices.x], cmul(_HShared[textureIndices.x][indices.y], weights));
		
		dispX = _DxShared[textureIndices.y][id] = cadd(_DxShared[textureIndices.x][indices.x], cmul(_DxShared[textureIndices.x][indices.y], weights));
		dispZ = _DzShared[textureIndices.y][id] = cadd(_DzShared[textureIndices.x][indices.x], cmul(_DzShared[textureIndices.x][indices.y], weights));
		
		slopeX = _SxShared[textureIndices.y][id] = cadd(_SxShared[textureIndices.x][indices.x], cmul(_SxShared[textureIndices.x][indices.y], weights));
		slopeZ = _SzShared[textureIndices.y][id] = cadd(_SzShared[textureIndices.x][indices.x], cmul(_SzShared[textureIndices.x][indices.y], weights));
		
		textureIndices.xy = textureIndices.yx;
	}
}

[numthreads(_Resolution, 1, 1)]
void Dispersion(uint3 id : SV_DispatchThreadID)
{
	float rcpPatchSize = _OceanScale[id.z];

	float n = id.x - HalfResolution;
	float m = id.y - HalfResolution;
	
	uint index = (id.z * _Resolution + id.y) * _Resolution + id.x;
	
	// Eq 43
	float4 h0 = OceanSpectrum[index];
	float wtk = OceanDispersion[index] * _Time * TimeScale;
	float2 h = cmul(h0.xy, cexp(cimg(wtk)));
	h = cadd(h, cmul(h0.zw, cexp(-cimg(wtk))));
	
	// Eq 37
	float2 k = TwoPi * float2(n, m) * rcpPatchSize;
	float kLengthRcp = rsqrt(dot(k, k));
		
	float2 slopeX = cmul(cimg(k.x), h);
	float2 slopeZ = cmul(cimg(k.y), h);

	// Eq 44
	float rcpKLength = (n || m) ? kLengthRcp : 0.0;
	float2 dispX = cmul(-cimg(k.x * rcpKLength), h);
	float2 dispZ = cmul(-cimg(k.y * rcpKLength), h);
	
	// Perform the FFT
	Fft(id.x, h, dispX, dispZ, slopeX, slopeZ);
	
	// Output results to textures
	HeightResult[id] = h;
	DisplacementResult[id] = float4(dispX, dispZ);
	SlopeResult[id] = float4(slopeX, slopeZ);
}

RWTexture2DArray<float3> DisplacementOutput;
Texture2DArray<float3> DisplacementInput;

Texture2DArray<float2> Height;
Texture2DArray<float4> Displacement, Slope;

RWTexture2DArray<float4> SmoothnessOutput0, SmoothnessOutput1, SmoothnessOutput2, SmoothnessOutput3, SmoothnessOutput4, SmoothnessOutput5, SmoothnessOutput6, SmoothnessOutput7;
RWTexture2DArray<float4> OceanNormalFoamSmoothness;

float _OceanScale0, _OceanWindSpeed0, _OceanWindDirection0, _OceanFetch0, _OceanSpreadBlend0, _OceanSwell0, _OceanPeakEnhancement0, _OceanShortWavesFade0;
float _OceanScale1, _OceanWindSpeed1, _OceanWindDirection1, _OceanFetch1, _OceanSpreadBlend1, _OceanSwell1, _OceanPeakEnhancement1, _OceanShortWavesFade1;
uint Size;

[numthreads(_Resolution, 1, 1)]
void FftColumns(uint3 id : SV_DispatchThreadID)
{
	uint2 texturePos = uint2(id.yx);

    // Load entire row or column into scratch array
	float2 height = Height[uint3(texturePos, id.z)];
	float4 displacement = Displacement[uint3(texturePos, id.z)];
	float4 slope = Slope[uint3(texturePos, id.z)];
	
	Fft(id.x, height, displacement.xy, displacement.zw, slope.xy, slope.zw);
	
	float sign = ((id.x + id.y) & 1) ? -1.0 : 1.0;
	DisplacementOutput[uint3(texturePos, id.z)] = float3(-displacement.x, height.x, -displacement.z) * sign;
	
	float3 normal = normalize(float3(-slope.xz * sign, 1.0));
	
	OceanNormalFoamSmoothness[uint3(texturePos, id.z)] = float4(normal.xy, 0.0, 0.0); // Snorm texture, need to put smoothness into -1 to 1 range
}

cbuffer CalculateNormalsProperties
{
	float4 _CascadeTexelSizes;
	float Smoothness;
	float _FoamStrength, _FoamDecay, _FoamThreshold;
	uint _OceanTextureSlicePreviousOffset;
};

[numthreads(8, 8, 1)]
void CalculateNormals(uint3 id : SV_DispatchThreadID)
{
    // Original change in x/y
	float delta = _CascadeTexelSizes[id.z];

	float3 left = DisplacementInput[int3((id.xy + int2(-1, 0)) % _Resolution, id.z)];
	float3 right = DisplacementInput[int3((id.xy + int2(1, 0)) % _Resolution, id.z)];
	float3 down = DisplacementInput[int3((id.xy + int2(0, -1)) % _Resolution, id.z)];
	float3 up = DisplacementInput[int3((id.xy + int2(0, 1)) % _Resolution, id.z)];

	float3 dx = (right - left) / (2.0 * delta);
	float3 dy = (up - down) / (2.0 * delta);
	
	float2 normalGradients = float2(-dx.y, -dy.y);
	
	float3 normal = normalize(float3(normalGradients, 1.0));
	normal.xy = OceanNormalFoamSmoothness[uint3(id.xy, id.z)].xy;
	float normalLength = SmoothnessToNormalLength(Smoothness);
	normal *= normalLength;
	
	// Eq 45
	float jxx = 1.0 + dx.x;
	float jyy = 1.0 + dy.z;
	float jxy = dx.x;
	float jyx = dy.z;
	
	float jacobian = jxx * jyy - jxy * jyx;
	OceanNormalFoamSmoothness[uint3(id.xy, id.z)] = float4(normal.xy, jacobian, Remap(normalLength, 2.0 / 3.0, 1.0, -1.0)); // Snorm texture, need to put smoothness into -1 to 1 range
}

// Thread group size of 32 is required to process  the entire 128x128 texture in shared memory
groupshared float4 mipDataShared[32][32];

static const uint ThreadCount = 32;

float4 UnpackData(float4 data)
{
	return float4(UnpackNormalSNorm(data.rg) * Remap(data.a, -1.0, 1.0, 2.0 / 3.0), data.b);
}

[numthreads(32, 32, 1)]
void GenerateFilteredMips(uint2 groupThreadID : SV_GroupThreadID, uint2 groupID : SV_GroupID, uint2 dispatchThreadID : SV_DispatchThreadID)
{
	uint depth = groupID.x;
	groupID = 0;
	dispatchThreadID.x %= Size;

	RWTexture2DArray<float4> result[8] = { SmoothnessOutput0, SmoothnessOutput1, SmoothnessOutput2, SmoothnessOutput3, SmoothnessOutput4, SmoothnessOutput5, SmoothnessOutput6, SmoothnessOutput7 };
	float4 mipDataSum = 0.0;

    [unroll]
	for (uint y = 0; y < 2; y++)
	{
        [unroll]
		for (uint x = 0; x < 2; x++)
		{
			uint2 offset = dispatchThreadID * 4 + 2 * uint2(x, y);

			// TODO: Gather?
			float4 mipData = UnpackData(SmoothnessOutput0[uint3(offset + uint2(0, 0), depth)]);
			mipData += UnpackData(SmoothnessOutput0[uint3(offset + uint2(1, 0), depth)]);
			mipData += UnpackData(SmoothnessOutput0[uint3(offset + uint2(0, 1), depth)]);
			mipData += UnpackData(SmoothnessOutput0[uint3(offset + uint2(1, 1), depth)]);
			mipData *= 0.25;

			float3 averageNormal = normalize(mipData.xyz);
			uint3 dst = uint3(dispatchThreadID * 2 + uint2(x, y), depth);
			result[1][dst] = float4(averageNormal.xy, mipData.w, Remap(length(mipData.xyz), 2.0 / 3.0, 1.0, -1.0));
			mipDataSum += mipData;
		}
	}

	mipDataSum *= 0.25;
	float3 averageNormal = normalize(mipDataSum.xyz);
	uint3 dst = uint3(dispatchThreadID, depth);
	result[2][dst] = float4(averageNormal.xy, mipDataSum.w, Remap(length(mipDataSum.xyz), 2.0 / 3.0, 1.0, -1.0));

	mipDataShared[groupThreadID.x][groupThreadID.y] = mipDataSum;

    [unroll]
	for (uint s = ThreadCount >> 1, i = 3; s > 0; s >>= 1, i++)
	{
		GroupMemoryBarrierWithGroupSync();
		
		float4 mipDataSum = 0.0;
		if (all(groupThreadID < s))
		{
            // Load four normals and average
			mipDataSum = mipDataShared[groupThreadID.x][groupThreadID.y];
			mipDataSum += mipDataShared[groupThreadID.x + s][groupThreadID.y];
			mipDataSum += mipDataShared[groupThreadID.x][groupThreadID.y + s];
			mipDataSum += mipDataShared[groupThreadID.x + s][groupThreadID.y + s];
			mipDataSum *= 0.25;

			float3 averageNormal = normalize(mipDataSum.xyz);
			uint3 dst = uint3(groupThreadID, depth);
			result[i][dst] = float4(averageNormal.xy, mipDataSum.w, Remap(length(mipDataSum.xyz), 2.0 / 3.0, 1.0, -1.0));
		}
		
		GroupMemoryBarrierWithGroupSync();
		
		if (all(groupThreadID < s))
		{
			uint2 ind = (groupThreadID / 2) + (groupThreadID % 2) * (s / 2);
			mipDataShared[ind.x][ind.y] = mipDataSum;
		}
	}
}
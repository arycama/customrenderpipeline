#include "../Complex.hlsl"
#include "../Math.hlsl"
#include "../Random.hlsl"
#include "../Material.hlsl"

#pragma kernel ComputeRows
#pragma kernel ComputeColumns
#pragma kernel CalculateNormals
#pragma kernel GenerateFilteredMips
#pragma kernel ComputeH0

cbuffer InitSpectrumProperties
{
	float4 _OceanScale, SpectrumStart, SpectrumEnd;
	float _OceanGravity, Time, TimeScale, SequenceLength;
};

RWBuffer<float> OceanDispersionWrite;
RWBuffer<float2> OceanSpectrumWrite;
Buffer<float> OceanDispersion;
Buffer<float2> OceanSpectrum;

RWTexture2DArray<float2> HeightResult;
RWTexture2DArray<float4> DisplacementResult, SlopeResult;

static const uint _Resolution = 128;
static const uint Log2Resolution = log2(_Resolution);
static const uint HalfResolution = _Resolution >> 1;

cbuffer OceanData
{
	float scale0;
	float windSpeed0;
	float windAngle0;
	float fetch0;
	float spreadBlend0;
	float swell0;
	float peakEnhancement0;
	float shortWavesFade0;
	float scale1;
	float windSpeed1;
	float windAngle1;
	float fetch1;
	float spreadBlend1;
	float swell1;
	float peakEnhancement1;
	float shortWavesFade1;
};

#define MAX_FFT_RESOLUTION 256
#define WARP_WIDTH 8 // minimum number of threads which execute in lockstep

uint m_resolution;
uint m_resolution_plus_one;
uint m_half_resolution;
uint m_half_resolution_plus_one;
uint m_resolution_plus_one_squared_minus_one;
uint m_32_minus_log2_resolution;

float4 m_window_in;
float4 m_window_out;

float2 m_wind_dir;
float4 m_frequency_scale;
float4 m_linear_scale;
float m_wind_scale;
float m_root_scale;
float m_power_scale;

float m_time;

float m_choppy_scale;

// update H0 from Gauss (one CTA per row)
[numthreads(MAX_FFT_RESOLUTION, 1, 1)]
void ComputeH0(uint3 dispatchThreadId : SV_DispatchThreadID)
{
	float wk = 0;

	uint columnIdx = dispatchThreadId.x;
	uint rowIdx = dispatchThreadId.y;
	
	if (columnIdx < m_resolution)
	{
		int nx = columnIdx - m_half_resolution;
		int ny = rowIdx - m_half_resolution;
		float nr = sqrt(float(nx * nx + ny * ny));

		float amplitude = 0.0f;
		if ((nx || ny) && nr >= m_window_in[dispatchThreadId.z] && nr < m_window_out[dispatchThreadId.z])
		{
			float2 k = float2(nx * m_frequency_scale[dispatchThreadId.z], ny * m_frequency_scale[dispatchThreadId.z]);
		
			float kSqr = k.x * k.x + k.y * k.y;
			float kCos = k.x * m_wind_dir.x + k.y * m_wind_dir.y;

			//float scale = m_linear_scale[dispatchThreadId.z] * kCos * rsqrt(kSqr * kSqr * kSqr);
			float scale = m_linear_scale[dispatchThreadId.z] * sqrt(pow(kCos * rsqrt(kSqr), 6.0)) * rsqrt(kSqr * kSqr);
			
			if (kCos < 0)
				scale *= m_wind_scale;
				
			amplitude = scale * exp(m_power_scale * kSqr + m_root_scale / kSqr);
			
			float w0 = TwoPi / SequenceLength;
			wk = floor(sqrt(_OceanGravity * length(k)) / w0) * w0;
		}
		
		uint index = (dispatchThreadId.z * m_resolution_plus_one + rowIdx) * m_resolution_plus_one + columnIdx;
		float2 h0 = amplitude * GaussianFloat2(index);
		OceanSpectrumWrite[index] = h0;
		OceanDispersionWrite[index] = wk;
		
		// mirror first row/column, CPU and CUDA paths don't do that
		// however, we need to initialize the N+1'th row/column to zero 
		if (!rowIdx || !columnIdx)
		{
			OceanSpectrumWrite[m_resolution_plus_one_squared_minus_one - index] = 0; //h0;
			//OceanDispersionWrite[m_resolution_plus_one_squared_minus_one - index] = 0;
		}
	}
}

groupshared float2 _HShared[2][_Resolution];
groupshared float2 _DxShared[2][_Resolution];
groupshared float2 _DzShared[2][_Resolution];
groupshared float2 _SxShared[2][_Resolution];
groupshared float2 _SzShared[2][_Resolution];

void Fft(uint id, inout float2 height, inout float2 dispX, inout float2 dispZ, inout float2 slopeX, inout float2 slopeZ)
{
    // Load entire row or column into scratch array
	_HShared[0][id] = height;
	_DxShared[0][id] = dispX;
	_DzShared[0][id] = dispZ;
	_SxShared[0][id] = slopeX;
	_SzShared[0][id] = slopeZ;

	for (uint i = 0; i < Log2Resolution; i++)
	{
		GroupMemoryBarrierWithGroupSync();

		uint sectionWidth = 2 << i;
		uint halfSectionWidth = sectionWidth / 2;

		uint sectionStartOffset = id & ~(sectionWidth - 1);
		uint halfSectionOffset = id & (halfSectionWidth - 1);
		uint sectionOffset = id & (sectionWidth - 1);
		
		float2 weights = cexp(cimg(2.0 * Pi * sectionOffset / sectionWidth));

		uint2 indices = sectionStartOffset + halfSectionOffset;
		indices.y += halfSectionWidth;

		if (i == 0)
			indices = reversebits(indices) >> (32 - Log2Resolution) & (_Resolution - 1);
			
		uint2 textureIndices = (i & 1) ? uint2(1, 0) : uint2(0, 1);
		
		height = _HShared[textureIndices.y][id] = cadd(_HShared[textureIndices.x][indices.x], cmul(_HShared[textureIndices.x][indices.y], weights));
		
		dispX = _DxShared[textureIndices.y][id] = cadd(_DxShared[textureIndices.x][indices.x], cmul(_DxShared[textureIndices.x][indices.y], weights));
		dispZ = _DzShared[textureIndices.y][id] = cadd(_DzShared[textureIndices.x][indices.x], cmul(_DzShared[textureIndices.x][indices.y], weights));
		
		slopeX = _SxShared[textureIndices.y][id] = cadd(_SxShared[textureIndices.x][indices.x], cmul(_SxShared[textureIndices.x][indices.y], weights));
		slopeZ = _SzShared[textureIndices.y][id] = cadd(_SzShared[textureIndices.x][indices.x], cmul(_SzShared[textureIndices.x][indices.y], weights));
	}
}

groupshared float2 uData[MAX_FFT_RESOLUTION / 2];
groupshared float2 vData[MAX_FFT_RESOLUTION / 2];
groupshared float2 wData[MAX_FFT_RESOLUTION / 2];

// input is bit-reversed threadIdx and threadIdx+1
// output is threadIdx and threadIdx + resolution/2
void fft(inout float2 u[2], inout float2 v[2], inout float2 w[2], uint threadIdx)
{
	bool flag = false;
	float scale = 3.14159265359f * 0.5f; // Pi

	if (threadIdx < m_half_resolution)
	{
		{
			uint i = threadIdx;

			float2 du = u[1];
			float2 dv = v[1];
			float2 dw = w[1];
				
			u[1] = u[0] - du;
			u[0] = u[0] + du;
			v[1] = v[0] - dv;
			v[0] = v[0] + dv;
			w[1] = w[0] - dw;
			w[0] = w[0] + dw;
			
			flag = threadIdx & 1;

			// much slower: vData[i] = v[!flag];
			if (flag)
			{
				uData[i] = u[0];
				vData[i] = v[0];
				wData[i] = w[0];
			}
			else
			{
				uData[i] = u[1];
				vData[i] = v[1];
				wData[i] = w[1];
			}

			GroupMemoryBarrier();
		}

		[unroll(2)] // log2(WARP_WIDTH) - 1
		for (uint stride = 2; stride < WARP_WIDTH; stride <<= 1, scale *= 0.5f)
		{
			uint i = threadIdx ^ (stride - 1);
			uint j = threadIdx & (stride - 1);

			// much slower: v[!flag] = vData[i];
			if (flag)
			{
				u[0] = uData[i];
				v[0] = vData[i];
				w[0] = wData[i];
			}
			else
			{
				u[1] = uData[i];
				v[1] = vData[i];
				w[1] = wData[i];
			}

			float sin, cos;
			sincos(j * scale, sin, cos);

			float2 du = float2(
				cos * u[1].x - sin * u[1].y,
				sin * u[1].x + cos * u[1].y);
			float2 dv = float2(
				cos * v[1].x - sin * v[1].y,
				sin * v[1].x + cos * v[1].y);
			float2 dw = float2(
				cos * w[1].x - sin * w[1].y,
				sin * w[1].x + cos * w[1].y);

			u[1] = u[0] - du;
			u[0] = u[0] + du;
			v[1] = v[0] - dv;
			v[0] = v[0] + dv;
			w[1] = w[0] - dw;
			w[0] = w[0] + dw;

			flag = threadIdx & stride;

			// much slower: vData[i] = v[!flag];
			if (flag)
			{
				uData[i] = u[0];
				vData[i] = v[0];
				wData[i] = w[0];
			}
			else
			{
				uData[i] = u[1];
				vData[i] = v[1];
				wData[i] = w[1];
			}

			GroupMemoryBarrier();
		}
	}

	[unroll(6)] // log2(MAX_FFT_RESOLUTION) - log2(WARP_WIDTH)
	for (uint stride = WARP_WIDTH; stride < m_resolution; stride <<= 1, scale *= 0.5f)
	{
		if (threadIdx < m_half_resolution)
		{
			uint i = threadIdx ^ (stride - 1);
			uint j = threadIdx & (stride - 1);

			// much slower: v[!flag] = vData[i];
			if (flag)
			{
				u[0] = uData[i];
				v[0] = vData[i];
				w[0] = wData[i];
			}
			else
			{
				u[1] = uData[i];
				v[1] = vData[i];
				w[1] = wData[i];
			}

			float sin, cos;
			sincos(j * scale, sin, cos);

			float2 du = float2(
				cos * u[1].x - sin * u[1].y,
				sin * u[1].x + cos * u[1].y);
			float2 dv = float2(
				cos * v[1].x - sin * v[1].y,
				sin * v[1].x + cos * v[1].y);
			float2 dw = float2(
				cos * w[1].x - sin * w[1].y,
				sin * w[1].x + cos * w[1].y);

			u[1] = u[0] - du;
			u[0] = u[0] + du;
			v[1] = v[0] - dv;
			v[0] = v[0] + dv;
			w[1] = w[0] - dw;
			w[0] = w[0] + dw;

			flag = threadIdx & stride;

			// much slower: vData[i] = v[!flag];
			if (flag)
			{
				uData[i] = u[0];
				vData[i] = v[0];
				wData[i] = w[0];
			}
			else
			{
				uData[i] = u[1];
				vData[i] = v[1];
				wData[i] = w[1];
			}
		}
		
		GroupMemoryBarrierWithGroupSync();
	}
}

// update Ht, Dt_x, Dt_y from H0 and Omega, fourier transform per row (one CTA per row)
[numthreads(MAX_FFT_RESOLUTION / 2, 1, 1)]
void ComputeRows(uint3 id : SV_DispatchThreadID)
{
	uint3 dispatchThreadId = id;
	uint sliceOffset = id.z * m_resolution_plus_one * m_resolution_plus_one;
	
	uint columnIdx = dispatchThreadId.x;// * 2;
	uint rowIdx = dispatchThreadId.y;
	uint reverseColumnIdx = reversebits(columnIdx) >> m_32_minus_log2_resolution;
	//int3 n = int3(reverseColumnIdx - m_half_resolution, reverseColumnIdx, rowIdx - m_half_resolution);
	
	reverseColumnIdx = columnIdx;
	
	float2 h, dispX, dispZ, slopeX, slopeZ;
	
	float2 ht[2], dx[2], dy[2];
	if (columnIdx < m_resolution)
	{
		float4 h0i, h0j;
		double2 omega;
		
		uint h0_index = rowIdx * m_resolution_plus_one + reverseColumnIdx;
		uint h0_jndex = h0_index + m_half_resolution;
		uint omega_index = rowIdx * m_half_resolution_plus_one;
		uint omega_jndex = omega_index + m_half_resolution;
		
		h0i.xy = OceanSpectrum[h0_index + sliceOffset];
		h0j.xy = OceanSpectrum[m_resolution_plus_one_squared_minus_one - h0_index + sliceOffset];
		omega.x = OceanDispersion[omega_index + reverseColumnIdx + sliceOffset] * m_time;

		h0i.zw = OceanSpectrum[h0_jndex + sliceOffset];
		h0j.zw = OceanSpectrum[m_resolution_plus_one_squared_minus_one - h0_jndex + sliceOffset];
		omega.y = OceanDispersion[omega_jndex - reverseColumnIdx] * m_time;
		
		int n = (int) id.x - HalfResolution;
		int m = (int) id.y - HalfResolution;
	
		uint index = (id.z * m_resolution_plus_one + id.y) * m_resolution_plus_one + id.x;
	
		// Eq 43
		float4 h0;
		h0.xy = h0i.xy;
		h0.zw = conj(h0j.xy);
	
		float wtk = OceanDispersion[index] * Time * TimeScale;
		h = cmul(h0.xy, cexp(cimg(wtk)));
		h = cadd(h, cmul(h0.zw, cexp(-cimg(wtk))));
	
		// Eq 37
		float2 k = TwoPi * float2(n, m) * _OceanScale[id.z];
		float kLengthRcp = rsqrt(dot(k, k));
		
		slopeX = cmul(cimg(k.x), h);
		slopeZ = cmul(cimg(k.y), h);

		// Eq 44
		float rcpKLength = (n || m) ? kLengthRcp : 0.0;
		dispX = cmul(-cimg(k.x * rcpKLength), h);
		dispZ = cmul(-cimg(k.y * rcpKLength), h);
	}
	
	// Perform the FFT
	Fft(id.x, h, dispX, dispZ, slopeX, slopeZ);
	
	// Output results to textures
	HeightResult[id] = h;
	DisplacementResult[id] = float4(dispX, dispZ);
	SlopeResult[id] = float4(slopeX, slopeZ);
}

RWTexture2DArray<float3> DisplacementOutput;
RWTexture2DArray<float4> OceanNormalFoamSmoothness;
Texture2DArray<float2> Height;
Texture2DArray<float4> Displacement, Slope;

// do fourier transform per row of Ht, Dt_x, Dt_y, write displacement texture (one CTA per column)
[numthreads(MAX_FFT_RESOLUTION / 2, 1, 1)]
void ComputeColumns(uint3 id : SV_DispatchThreadID)
{
	uint3 dispatchThreadId = id;
	uint rowIdx = dispatchThreadId.x;// * 2;
	uint columnIdx = dispatchThreadId.y;
	uint reverseRowIdx = reversebits(rowIdx) >> m_32_minus_log2_resolution;

	int index = reverseRowIdx * m_resolution + columnIdx;
	int jndex = (m_half_resolution - reverseRowIdx) * m_resolution + columnIdx;

	float2 ht[2], dx[2], dy[2];
	if (rowIdx < m_resolution)
	{
		//ht[0] = g_ht_input[index];
		//ht[1] = g_ht_input[jndex];
		//ht[1].y = -ht[1].y;

		//float4 dti = g_dt_input[index];
		//float4 dtj = g_dt_input[jndex];

		//dx[0] = dti.xy;
		//dx[1] = float2(dtj.x, -dtj.y);
		//dy[0] = dti.zw;
		//dy[1] = float2(dtj.z, -dtj.w);
	}

	//fft(ht, dx, dy, dispatchThreadId.x);
	
	// Load entire row or column into scratch array
	float2 height = Height[id.yxz];
	float4 displacement = Displacement[id.yxz];
	float4 slope = Slope[id.yxz];
	
	Fft(id.x, height, displacement.xy, displacement.zw, slope.xy, slope.zw);
	
	dx[0] = -displacement.xy;
	dy[0] = -displacement.zw;
	ht[0] = height;
	
	if (rowIdx < m_resolution)
	{
		float sgn = (dispatchThreadId.x + columnIdx) & 0x1 ? -1.0f : +1.0f;
		float scale = m_choppy_scale * sgn;

		DisplacementOutput[uint3(columnIdx, dispatchThreadId.x, id.z)] = float4(dx[0].x * scale, dy[0].x * scale, ht[0].x * sgn, 0).xzyw;
		//DisplacementOutput[uint3(columnIdx, dispatchThreadId.x + m_half_resolution, id.z)] = float4(dx[1].x * scale, dy[1].x * scale, ht[1].x * sgn, 0).xzyw;
		
		float3 normal = normalize(float3(-slope.xz * sgn, 1.0));
		OceanNormalFoamSmoothness[uint3(columnIdx, dispatchThreadId.x, id.z)] = float4(normal.xy, 0.0, 0.0);
	}
}

cbuffer CalculateNormalsProperties
{
	float4 _CascadeTexelSizes;
	float Smoothness;
	float _FoamStrength, _FoamDecay, _FoamThreshold;
	uint _OceanTextureSlicePreviousOffset;
};

Texture2DArray<float3> DisplacementInput;

[numthreads(8, 8, 1)]
void CalculateNormals(uint3 id : SV_DispatchThreadID)
{
    // Original change x/y
	float delta = _CascadeTexelSizes[id.z];

	float3 left = DisplacementInput[int3((id.xy + int2(-1, 0)) % _Resolution, id.z)];
	float3 right = DisplacementInput[int3((id.xy + int2(1, 0)) % _Resolution, id.z)];
	float3 down = DisplacementInput[int3((id.xy + int2(0, -1)) % _Resolution, id.z)];
	float3 up = DisplacementInput[int3((id.xy + int2(0, 1)) % _Resolution, id.z)];

	float3 dx = (right - left) / (2.0 * delta);
	float3 dy = (up - down) / (2.0 * delta);
	
	float2 normalGradients = float2(-dx.y, -dy.y);
	
	float3 normal = normalize(float3(normalGradients, 1.0));
	normal.xy = OceanNormalFoamSmoothness[uint3(id.xy, id.z)].xy;
	float normalLength = SmoothnessToNormalLength(Smoothness);
	normal *= normalLength;
	
	// Eq 45
	float jxx = 1.0 + dx.x;
	float jyy = 1.0 + dy.z;
	float jxy = dx.x;
	float jyx = dy.z;
	
	float jacobian = jxx * jyy - jxy * jyx;
	OceanNormalFoamSmoothness[uint3(id.xy, id.z)] = float4(normal.xy, jacobian, Remap(normalLength, 2.0 / 3.0, 1.0, -1.0)); // Snorm texture, need to put smoothness into -1 to 1 range
}

RWTexture2DArray<float4> SmoothnessOutput0, SmoothnessOutput1, SmoothnessOutput2, SmoothnessOutput3, SmoothnessOutput4, SmoothnessOutput5, SmoothnessOutput6, SmoothnessOutput7;
uint Size;

// Thread group size of 32 is required to process  the entire 128x128 texture in shared memory
groupshared float4 mipDataShared[32][32];

static const uint ThreadCount = 32;

float4 UnpackData(float4 data)
{
	return float4(UnpackNormalSNorm(data.rg) * Remap(data.a, -1.0, 1.0, 2.0 / 3.0), data.b);
}

[numthreads(32, 32, 1)]
void GenerateFilteredMips(uint2 groupThreadID : SV_GroupThreadID, uint2 groupID : SV_GroupID, uint2 dispatchThreadID : SV_DispatchThreadID)
{
	uint depth = groupID.x;
	groupID = 0;
	dispatchThreadID.x %= Size;

	RWTexture2DArray<float4> result[8] = { SmoothnessOutput0, SmoothnessOutput1, SmoothnessOutput2, SmoothnessOutput3, SmoothnessOutput4, SmoothnessOutput5, SmoothnessOutput6, SmoothnessOutput7 };
	float4 mipDataSum = 0.0;

    [unroll]
	for (uint y = 0; y < 2; y++)
	{
        [unroll]
		for (uint x = 0; x < 2; x++)
		{
			uint2 offset = dispatchThreadID * 4 + 2 * uint2(x, y);

			// TODO: Gather?
			float4 mipData = UnpackData(SmoothnessOutput0[uint3(offset + uint2(0, 0), depth)]);
			mipData += UnpackData(SmoothnessOutput0[uint3(offset + uint2(1, 0), depth)]);
			mipData += UnpackData(SmoothnessOutput0[uint3(offset + uint2(0, 1), depth)]);
			mipData += UnpackData(SmoothnessOutput0[uint3(offset + uint2(1, 1), depth)]);
			mipData *= 0.25;

			float3 averageNormal = normalize(mipData.xyz);
			uint3 dst = uint3(dispatchThreadID * 2 + uint2(x, y), depth);
			result[1][dst] = float4(averageNormal.xy, mipData.w, Remap(length(mipData.xyz), 2.0 / 3.0, 1.0, -1.0));
			mipDataSum += mipData;
		}
	}

	mipDataSum *= 0.25;
	float3 averageNormal = normalize(mipDataSum.xyz);
	uint3 dst = uint3(dispatchThreadID, depth);
	result[2][dst] = float4(averageNormal.xy, mipDataSum.w, Remap(length(mipDataSum.xyz), 2.0 / 3.0, 1.0, -1.0));

	mipDataShared[groupThreadID.x][groupThreadID.y] = mipDataSum;

    [unroll]
	for (uint s = ThreadCount >> 1, i = 3; s > 0; s >>= 1, i++)
	{
		GroupMemoryBarrierWithGroupSync();
		
		float4 mipDataSum = 0.0;
		if (all(groupThreadID < s))
		{
            // Load four normals and average
			mipDataSum = mipDataShared[groupThreadID.x][groupThreadID.y];
			mipDataSum += mipDataShared[groupThreadID.x + s][groupThreadID.y];
			mipDataSum += mipDataShared[groupThreadID.x][groupThreadID.y + s];
			mipDataSum += mipDataShared[groupThreadID.x + s][groupThreadID.y + s];
			mipDataSum *= 0.25;

			float3 averageNormal = normalize(mipDataSum.xyz);
			uint3 dst = uint3(groupThreadID, depth);
			result[i][dst] = float4(averageNormal.xy, mipDataSum.w, Remap(length(mipDataSum.xyz), 2.0 / 3.0, 1.0, -1.0));
		}
		
		GroupMemoryBarrierWithGroupSync();
		
		if (all(groupThreadID < s))
		{
			uint2 ind = (groupThreadID / 2) + (groupThreadID % 2) * (s / 2);
			mipDataShared[ind.x][ind.y] = mipDataSum;
		}
	}
}
 #pragma kernel Visibility

#pragma multi_compile _ HIZ_ON

#include "../../Common.hlsl"
#include "../../TerrainCommon.hlsl"
#include "../../Packing.hlsl"
#include "../../MatrixUtils.hlsl"

float _MaxHiZMip;
uint _InstanceCount;

StructuredBuffer<float4> _InstanceBounds;
RWStructuredBuffer<uint> _RendererInstanceIDs;

bool IsVisible(float3 boundsCenter, float3 boundsExtents)
{
	if (!FrustumCull(boundsCenter, boundsExtents))
		return false;
		
	float3 screenMin, screenMax;
	
	[unroll]
	for (uint z = 0, i = 0; z < 2; z++, i++)
	{
		[unroll]
		for (uint y = 0; y < 2; y++, i++)
		{
			[unroll]
			for (uint x = 0; x < 2; x++, i++)
			{
				float3 worldPosition = boundsCenter - boundsExtents + boundsExtents * 2 * float3(x, y, z);
				float3 screenPosition = MultiplyPointProj(WorldToScreen, worldPosition).xyz;
				screenMin = i ? min(screenMin, screenPosition) : screenPosition;
				screenMax = i ? max(screenMax, screenPosition) : screenPosition;
			}
		}
	}
	
	// Calculate hi-Z buffer mip https://interplayoflight.wordpress.com/2017/11/15/experiments-in-gpu-based-occlusion-culling/
	float2 size = (screenMax - screenMin).xy * ViewSize;
	float mip = ceil(log2(Max2(size)));
 
	// If object bounds is larger than entire screen, we can't conservatively reject it, so return visible
	if (mip > _MaxHiZMip)
		return true;
		
	if (mip > 0.0)
	{
		// Texel footprint for the lower (finer-grained) level
		float levelLower = mip - 1.0;
		float2 scale = exp2(-levelLower);
		float2 a = floor(screenMin.xy * scale);
		float2 b = ceil(screenMax.xy * scale);
 
		// Use the lower level if we only touch <= 2 texels in both dimensions
		if (all(b - a <= 2.0))
			mip = levelLower;
	}
	else
		mip = 0.0;
		
	// Check if this aabb will actually generate any pixels (Eg overlap the center of the target pixel
	if (mip == 0.0)
	{
		float2 screenCenter = 0.5 * (screenMax + screenMin).xy;
		float2 pixelCenter = floor(screenCenter) + 0.5;
		
		if (any(pixelCenter < screenMin.xy || pixelCenter > screenMax.xy))
			return false;
	}
	
	float2 mipRes = floor(ViewSize * exp2(-mip));
	float4 screenMinMax = float4(screenMin.xy, screenMax.xy) * mipRes.xyxy;
	screenMinMax = clamp(screenMinMax, 0, mipRes.xyxy - 1);
		
	return screenMax.z > HiZMaxDepth.mips[mip][screenMinMax.xy] ||
		screenMax.z > HiZMaxDepth.mips[mip][screenMinMax.zy] ||
		screenMax.z > HiZMaxDepth.mips[mip][screenMinMax.xw] ||
		screenMax.z > HiZMaxDepth.mips[mip][screenMinMax.zw];
}

[numthreads(1024, 1, 1)]
void Visibility(uint id : SV_DispatchThreadID)
{
	if (id >= _InstanceCount)
		return;
		
	float4 boundsData = _InstanceBounds[id];
	float3 boundsCenter = boundsData.xyz - ViewPosition;
	float3 boundsExtents = R11G11B10ToFloat3(asuint(boundsData.w));
	
	_RendererInstanceIDs[id] = IsVisible(boundsCenter, boundsExtents);
}

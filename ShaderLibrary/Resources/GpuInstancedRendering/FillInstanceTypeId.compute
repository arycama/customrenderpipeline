#pragma kernel FillData

#include "../../Common.hlsl"
#include "../../Packing.hlsl"
#include "../../IndirectRendering.hlsl"
#include "../../MatrixUtils.hlsl"

uint _Offset, _Count;

RWStructuredBuffer<uint> _InstanceTypeIds;
RWStructuredBuffer<float3x4> _PositionsResult;
RWStructuredBuffer<float> _LodFadesResult;
RWStructuredBuffer<float4> _InstanceBounds;

StructuredBuffer<float3x4> _PositionsInput;
StructuredBuffer<Bounds> _InstanceTypeBounds;
Buffer<uint> _InstanceTypeIdsInput;

[numthreads(1024, 1, 1)]
void FillData(uint id : SV_DispatchThreadID)
{
	if (id >= _Count)
		return;
	
	uint instanceType = _InstanceTypeIdsInput[id];
	float3x4 objectToWorld = _PositionsInput[id];
	Bounds bounds = _InstanceTypeBounds[instanceType];
	float3 boundsMin, boundsMax;

	[unroll]
	for (uint z = 0, i = 0; z < 2; z++)
	{
		[unroll]
		for (uint y = 0; y < 2; y++)
		{
			[unroll]
			for (uint x = 0; x < 2; x++, i++)
			{
				// Transform corners from object to world space, and calculate min/max for Frustum culling
				float3 objectPosition = bounds.min + bounds.size * float3(x, y, z);
				float3 worldPosition = MultiplyPoint3x4(objectToWorld, objectPosition);
				boundsMin = i ? min(boundsMin, worldPosition) : worldPosition;
				boundsMax = i ? max(boundsMax, worldPosition) : worldPosition;
			}
		}
	}
	
	float3 center = 0.5 * (boundsMax + boundsMin);
	float3 extents = 0.5 * (boundsMax - boundsMin);
	
	float4 packedBounds;
	packedBounds.xyz = center;
	packedBounds.w = asfloat(Float3ToR11G11B10(extents));
	
	_InstanceTypeIds[_Offset + id] = instanceType;
	_PositionsResult[_Offset + id] = objectToWorld;
	_LodFadesResult[_Offset + id] = 0;
	_InstanceBounds[_Offset + id] = packedBounds;
}
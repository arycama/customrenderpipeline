#pragma kernel PrefixScan0 KERNEL=PrefixScan0 WRITE_FINAL_COUNT
#pragma kernel PrefixScan1 KERNEL=PrefixScan1 WRITE_DRAW_CALL_COUNT

const static uint threadCount = 1024;

uint MaxThread;
RWStructuredBuffer<uint> PrefixSumsWrite, GroupSumsWrite, TotalInstanceCount;
StructuredBuffer<uint> Input;

groupshared uint temp[threadCount];
//groupshared uint temp[2 * threadCount];

[numthreads(threadCount, 1, 1)]
void KERNEL(uint dispatchThreadId : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	uint thid = groupIndex;
	uint n = threadCount;
	//uint n = threadCount * 2;
	uint offset = 1;
	
	// load input into shared memory
	temp[thid] = Input[dispatchThreadId];
	
	//temp[2 * thid + 0] = Input[2 * dispatchThreadId + 0];
	//temp[2 * thid + 1] = Input[2 * dispatchThreadId + 1];
	// temp[2*thid+1] = g_idata[2*thid+1];
	
	// build sum in place up the tree
	for (int d = n >> 1; d > 0; d >>= 1)
	{
		GroupMemoryBarrierWithGroupSync();
		
		if (thid < d)
		{
			uint ai = offset * (2 * thid + 1) - 1;
			uint bi = offset * (2 * thid + 2) - 1;
			temp[bi] += temp[ai];
		}
		
		offset *= 2;
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	// clear the last element
	if (thid == 0)
	{
		#ifdef WRITE_FINAL_COUNT
			GroupSumsWrite[groupId] = temp[n - 1];
		#endif

		#ifdef WRITE_DRAW_CALL_COUNT
			TotalInstanceCount[0] = temp[n - 1];
		#endif
	
		temp[n - 1] = 0;
	}
	
	// traverse down tree & build scan
	//for (uint i = 0; i < log2(threadCount); i++)
	
	for (int d = 1; d < n; d *= 2)
	{
		offset >>= 1;
		GroupMemoryBarrierWithGroupSync();

		if (thid < d)
		{
			uint ai = offset * (2 * thid + 1) - 1;
			uint bi = offset * (2 * thid + 2) - 1;
			uint t = temp[ai];
			temp[ai] = temp[bi];
			temp[bi] += t;
		}
	}
	
	GroupMemoryBarrierWithGroupSync();
	PrefixSumsWrite[dispatchThreadId] = temp[thid];
	
	//PrefixSumsWrite[2 * dispatchThreadId + 0] = temp[2 * thid + 0];
	//PrefixSumsWrite[2 * dispatchThreadId + 1] = temp[2 * thid + 1];
}
#include "../../Common.hlsl"
#include "../../Geometry.hlsl"
#include "../../IndirectRendering.hlsl"
#include "../../Packing.hlsl"
#include "../../SpaceTransforms.hlsl"

#pragma kernel InstanceCompaction

// Since we use groupId to index the instance prefix sum, this needs to match
const static uint threadCount = 1024;
const static uint log2ThreadCount = firstbitlow(threadCount);

uint MaxThread;

RWStructuredBuffer<uint> Output;
RWStructuredBuffer<uint> SortKeysWrite;
RWStructuredBuffer<uint> LodCounts;

StructuredBuffer<uint> Input;
StructuredBuffer<uint> GroupSums, PrefixSums;
StructuredBuffer<float4> InstanceBounds;

StructuredBuffer<uint> InstanceTypeIds;
StructuredBuffer<InstanceTypeData> InstanceTypeDatas;
StructuredBuffer<InstanceTypeLodData> InstanceTypeLodDatas;
StructuredBuffer<float> LodSizes;
StructuredBuffer<float3x4> InstanceMatrices;

[numthreads(threadCount, 1, 1)]
void InstanceCompaction(uint id : SV_DispatchThreadID, uint groupId : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
	if (id >= MaxThread || !Input[id])
		return;

	uint dest = PrefixSums[id] + GroupSums[groupId];
	Output[dest] = id;
	
	// Compute sort key from instanceType, lod and viewDistance
	float4 boundsData = InstanceBounds[id];
	float3 boundsCenter = boundsData.xyz - ViewPosition;
	float3 boundsExtents = R11G11B10ToFloat3(asuint(boundsData.w));
	
	// Calculate lod (Assume 0 for now)
	uint instanceType = InstanceTypeIds[id];
	InstanceTypeData instanceTypeData = InstanceTypeDatas[instanceType];
	
	uint maxLodCount = min(8, instanceTypeData.lodCount);
	uint lod = maxLodCount - 1;
	float3x4 objectToWorld = InstanceMatrices[id];
	float worldSpaceScale = Max3(float3(length(objectToWorld._11_21_31), length(objectToWorld._12_22_32), length(objectToWorld._13_23_33)));
	float worldRadius = worldSpaceScale * instanceTypeData.radius; // TODO: Maybe use AABB max instead?
	float3 worldReferencePoint = MultiplyPoint3x4(objectToWorld, instanceTypeData.localReferencePoint) - ViewPosition;
	float screenHeight = ProjectedSphereRadius(worldRadius, worldReferencePoint, rcp(TanHalfFov));
	
	float viewZ = abs(dot(worldReferencePoint, ViewForward));
	
	// TODO: Currently a lod greater than cutoff distance will still be rendered. We can't remove it from drawing here because
	// the total instance sum has already been calculated by a previous prefix sum. Should instead remove it from the instance cull stage
	[unroll]
	for (uint i = 0; i < maxLodCount; i++)
	{
		uint index = instanceTypeData.lodSizebufferPosition + i;
		float lodSize = LodSizes[index];
	
		if (screenHeight <= lodSize)
			continue;
			
		lod = i;
		break;
	}
	
	uint lodInfoIndex = instanceTypeData.lodRendererOffset + lod;
	InterlockedAdd(LodCounts[lodInfoIndex], 1);
	
	// Logarithmic distribution
	uint viewZNorm = Remap(viewZ, Near, Far, 0.0, 65536.0);
	uint sortKey = viewZNorm | (lod << 16) | (instanceType << 19);
	SortKeysWrite[dest] = sortKey;
}

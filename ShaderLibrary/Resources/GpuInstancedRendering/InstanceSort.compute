#include "../../Math.hlsl"
#include "../../PrefixSum.hlsl"

#pragma kernel RadixCount COUNT
#pragma kernel RadixScan SCAN
#pragma kernel RadixScatter SCATTER

const static uint threadCount = 256;

RWStructuredBuffer<uint> KeysResult, DataResult;
RWStructuredBuffer<uint4> CountResult, ScanResult, ScanResultTemp;
StructuredBuffer<uint> Keys, Data, TotalGroupCount;
StructuredBuffer<uint4> GroupCounts, GroupScans, ScanResultTempRead;
uint BitIndex;

groupshared uint sharedSums[threadCount];

cbuffer DataLength
{
	uint TotalLength;
	uint pad0;
	uint pad1;
	uint pad2;
};

void PrefixSumSharedWrite(uint index, uint data)
{
	sharedSums[index] = data;
}

uint PrefixSumSharedRead(uint index)
{
	return sharedSums[index];
}

[numthreads(threadCount, 1, 1)]
void RadixCount(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	// Count the elements for this block
	bool outOfRange = id >= TotalLength;
	uint key = outOfRange ? UintMax : Keys[id];
	uint data = outOfRange ? 0 : Data[id];
	uint value = (key >> BitIndex) & 0x3;
	
	// Count and sort
	uint4 sums, offsets;
	offsets.x = PrefixSum(value == 0, groupIndex, threadCount, sums.x);
	offsets.y = PrefixSum(value == 1, groupIndex, threadCount, sums.y) + sums.x;
	offsets.z = PrefixSum(value == 2, groupIndex, threadCount, sums.z) + sums.x + sums.y;
	offsets.w = PrefixSum(value == 3, groupIndex, threadCount, sums.w) + sums.x + sums.y + sums.z;
	
	if (!groupIndex)
		CountResult[groupId] = sums;
		
	uint d = value == 0 ? offsets.x : (value == 1 ? offsets.y : (value == 2 ? offsets.z : offsets.w));
	
	// Write to global memory
	KeysResult[groupId * threadCount + d] = key;
	DataResult[groupId * threadCount + d] = data;
}

[numthreads(threadCount, 1, 1)]
void RadixScan(uint groupIndex : SV_GroupIndex)
{
	// Prefix sum the counts
	bool outOfRange = groupIndex >= TotalGroupCount[0];
	uint4 counts = outOfRange ? 0 : GroupCounts[groupIndex];
	
	uint4 sums, offsets;
	offsets.x = PrefixSum(counts.x, groupIndex, threadCount, sums.x);
	offsets.y = PrefixSum(counts.y, groupIndex, threadCount, sums.y);
	offsets.z = PrefixSum(counts.z, groupIndex, threadCount, sums.z);
	offsets.w = PrefixSum(counts.w, groupIndex, threadCount, sums.w);
	
	offsets.yzw += sums.x;
	offsets.zw += sums.y;
	offsets.w += sums.z;
	
	ScanResultTemp[groupIndex] = sums;
	ScanResult[groupIndex] = offsets;
}

[numthreads(threadCount, 1, 1)]
void RadixScatter(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	if (id >= TotalLength)
		return;

	uint key = Keys[id];
	uint value = (key >> BitIndex) & 0x3;
	
	uint4 localOffsets = GroupCounts[groupId];
	uint4 globalOffsets = GroupScans[groupId];
	
	uint4 globalCounts = ScanResultTempRead[groupId];
	
	uint localOffset;
	switch (value)
	{
		case 0:
			localOffset = 0;
			break;
		case 1:
			localOffset = localOffsets.x;
			break;
		case 2:
			localOffset = localOffsets.x + localOffsets.y;
			break;
		case 3:
			localOffset = localOffsets.x + localOffsets.y + localOffsets.z;
			break;
	}
	
	uint globalOffset = value == 0 ? globalOffsets.x : (value == 1 ? globalOffsets.y : (value == 2 ? globalOffsets.z : globalOffsets.w));
	
	uint globalDest = groupIndex - localOffset + globalOffset;
	
	// Write final results
	DataResult[globalDest] = Data[id];
	KeysResult[globalDest] = key;
}

#include "../../Math.hlsl"
#include "../../PrefixSum.hlsl"

#pragma kernel RadixCount COUNT
#pragma kernel RadixScan SCAN
#pragma kernel RadixScatter SCATTER
//#pragma enable_d3d11_debug_symbols

#ifdef SCAN
const static uint threadCount = 512;
#else
const static uint threadCount = 128;
#endif

RWStructuredBuffer<uint> KeysResult, DataResult, CountResult, TotalSumsResult, ScanResult;
StructuredBuffer<uint> Keys, Data, TotalGroupCount, GroupCounts, TotalSums, GroupScans;
uint BitIndex;

groupshared uint sharedSums[threadCount];

cbuffer DataLength
{
	uint TotalLength;
	uint pad0;
	uint pad1;
	uint pad2;
};

void PrefixSumSharedWrite(uint index, uint data)
{
	sharedSums[index] = data;
}

uint PrefixSumSharedRead(uint index)
{
	return sharedSums[index];
}

const static uint BitsPerPass = 2;
const static uint Exp2BitsPerPass = 1 << BitsPerPass;
groupshared uint SharedSums[2][Exp2BitsPerPass]; // Double buffered, so two indices per element

[numthreads(threadCount, 1, 1)]
void RadixCount(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	// Count the elements for this block
	bool outOfRange = id >= TotalLength;
	uint key = outOfRange ? UintMax : Keys[id];
	uint data = outOfRange ? 0 : Data[id];
	uint value = (key >> BitIndex) & 0x3;
	
	// Count and sort
	uint4 packedValues = (value == uint4(0, 1, 2, 3)) << uint4(0, 8, 16, 24);
	uint packedValue = packedValues.x | packedValues.y | packedValues.z | packedValues.w;
	
	uint packedSum;
	uint packedOffset = PrefixSum(packedValue, groupIndex, threadCount, packedSum);
	
	// Unpack sums and offset?
	uint4 offsets = (packedOffset >> uint4(0, 8, 16, 24)) & 0xFF;
	uint4 sums = (packedSum >> uint4(0, 8, 16, 24)) & 0xFF;

	// Prefix sum
	uint sum = groupIndex ? sums[groupIndex - 1] : 0;
	if (groupIndex < Exp2BitsPerPass)
		SharedSums[0][groupIndex] = sum;
	
	[unroll]
	for (uint i = 0; i < BitsPerPass; i++)
	{
		GroupMemoryBarrierWithGroupSync();
		
		if (groupIndex >= Exp2BitsPerPass)
			continue;
	
		uint offset = 1 << i;
		if (groupIndex >= offset)
			sum += SharedSums[i & 1][groupIndex - offset];
			
		SharedSums[!(i & 1)][groupIndex] = sum;
	}
	GroupMemoryBarrierWithGroupSync();
	
	uint d = offsets[value] + SharedSums[0][value];
	
	// Write to global memory
	KeysResult[groupId * threadCount + d] = key;
	DataResult[groupId * threadCount + d] = data;
	
	if (!groupIndex)
		CountResult[groupId] = packedSum;
}

[numthreads(threadCount, 1, 1)]
void RadixScan(uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	// Prefix sum the counts
	bool outOfRange = groupIndex >= TotalGroupCount[0];
	uint packedCount = outOfRange ? 0 : GroupCounts[groupIndex];
	uint4 counts = (packedCount >> uint4(0, 8, 16, 24)) & 0xFF;

	uint count = counts[groupId];
	uint sum;
	uint offset = PrefixSum(count, groupIndex, threadCount, sum);
	
	ScanResult[4 * groupIndex + groupId] = offset;
	
	if (!groupIndex)
		TotalSumsResult[groupId] = sum;
}

// Double buffered, so two indices per element
groupshared uint SharedLocalOffsets[2][Exp2BitsPerPass];
groupshared uint SharedGlobalOffsets[2][Exp2BitsPerPass];

[numthreads(threadCount, 1, 1)]
void RadixScatter(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	bool outOfRange = id >= TotalLength;
	uint key = outOfRange ? UintMax : Keys[id];
	uint data = outOfRange ? 0 : Data[id];
	uint value = (key >> BitIndex) & 0x3;
	
	uint packedLocalOffsets = GroupCounts[groupId];
	uint4 localOffsets = (packedLocalOffsets >> uint4(0, 8, 16, 24)) & 0xFF;
	
	// Prefix sum
	uint localSum = 0, globalSum = 0;
	if (groupIndex < Exp2BitsPerPass)
	{
		localSum = groupIndex ? localOffsets[groupIndex - 1] : 0;
		SharedLocalOffsets[0][groupIndex] = localSum;
		
		globalSum = GroupScans[groupId * 4 + groupIndex];
		SharedGlobalOffsets[0][groupIndex] = globalSum;
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	if (groupIndex && groupIndex < Exp2BitsPerPass)
	{
		globalSum += TotalSums[groupIndex - 1] - SharedGlobalOffsets[0][groupIndex - 1];
		SharedGlobalOffsets[0][groupIndex] = globalSum;
	}
	
	[unroll]
	for (uint i = 0; i < BitsPerPass; i++)
	{
		GroupMemoryBarrierWithGroupSync();
		
		if (groupIndex >= Exp2BitsPerPass)
			continue;
	
		uint offset = 1 << i;
		if (groupIndex >= offset)
		{
			localSum += SharedLocalOffsets[i & 1][groupIndex - offset];
			globalSum += SharedGlobalOffsets[i & 1][groupIndex - offset];
		}
			
		SharedLocalOffsets[!(i & 1)][groupIndex] = localSum;
		SharedGlobalOffsets[!(i & 1)][groupIndex] = globalSum;
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	// Write final results
	// Hrmmm could we actually do this whole thing in a single prefix sum somehow..
	uint globalDest = groupIndex - SharedLocalOffsets[0][value] + SharedGlobalOffsets[0][value];
	KeysResult[globalDest] = key;
	DataResult[globalDest] = data;
}

#include "../../Math.hlsl"
#include "../../PrefixSum.hlsl"

#pragma kernel RadixCount COUNT
#pragma kernel RadixScan SCAN
#pragma kernel RadixScatter SCATTER

#ifdef SCAN
	const static uint threadCount = 1024;
#else
	const static uint threadCount = 256;
#endif

RWStructuredBuffer<uint> KeysResult, DataResult, CountResult, ScanResult, TotalFalsesResult;
StructuredBuffer<uint> Keys, Data, GroupCounts, TotalGroupCount, TotalFalses, GroupScans;
uint BitIndex;

groupshared uint sharedSums[2 * threadCount];
groupshared uint SharedTotalFalses;

uint GroupId;
float IsPass1;

cbuffer DataLength
{
	uint TotalLength;
	uint pad0;
	uint pad1;
	uint pad2;
};

void PrefixSumSharedWrite(uint index, uint data)
{
	sharedSums[index] = data;
}

uint PrefixSumSharedRead(uint index)
{
	return sharedSums[index];
}

void PrefixSumOutputTotalCount(uint totalSum)
{
	#ifdef COUNT
		if(!IsPass1)
		{
			SharedTotalFalses = totalSum;
			CountResult[2 * GroupId + 0] = totalSum;
		}
		else
			CountResult[2 * GroupId + 1] = totalSum;
	#endif

	#ifdef SCAN
	if(!IsPass1)
		TotalFalsesResult[0] = totalSum;
	#endif
}

[numthreads(threadCount, 1, 1)]
void RadixCount(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	GroupId = groupId;
	
	// Count the elements for this block
	bool outOfRange = id >= TotalLength;
	uint key = outOfRange ? 0xFFFFFFFF : Keys[id];
	uint data = outOfRange ? 0 : Data[id];
	bool bit = (key >> BitIndex) & 0x1;
	
	// Shuffle in group memory based on counter
	uint f = PrefixSum(!bit, groupIndex, threadCount);
	
	IsPass1 = true;
	uint t = SharedTotalFalses + PrefixSum(bit, groupIndex, threadCount);
	uint d = bit ? t : f;
	
	// Write to global memory
	KeysResult[groupId * threadCount + d] = key;
	DataResult[groupId * threadCount + d] = data;
}

[numthreads(threadCount, 1, 1)]
void RadixScan(uint groupIndex : SV_GroupIndex)
{
	// Prefix sum the counts
	bool outOfRange = groupIndex >= TotalGroupCount[0];
	ScanResult[2 * groupIndex + 0] = PrefixSum(outOfRange ? 0 : GroupCounts[2 * groupIndex + 0], groupIndex, threadCount);
	
	IsPass1 = true;
	ScanResult[2 * groupIndex + 1] = PrefixSum(outOfRange ? 0 : GroupCounts[2 * groupIndex + 1], groupIndex, threadCount);
}

[numthreads(threadCount, 1, 1)]
void RadixScatter(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	if (id >= TotalLength)
		return;

	uint key = Keys[id];
	uint data = Data[id];
	bool bit = (key >> BitIndex) & 0x1;
	
	uint groupScan = GroupScans[2 * groupId + 0];
	uint localOffset = bit ? GroupCounts[2 * groupId + 0] : 0;
	uint globalOffset = bit ? GroupScans[2 * groupId + 1] + TotalFalses[0] : groupScan;
	uint globalDest = groupIndex - localOffset + globalOffset;
	
	// Write final results
	DataResult[globalDest] = data;
	KeysResult[globalDest] = key;
}

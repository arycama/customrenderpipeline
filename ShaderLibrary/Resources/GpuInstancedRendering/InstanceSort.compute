#include "../../Math.hlsl"
#include "../../PrefixSum.hlsl"

#pragma kernel RadixCount COUNT
#pragma kernel RadixScan SCAN
#pragma kernel RadixScatter SCATTER
//#pragma enable_d3d11_debug_symbols

#ifdef SCAN
	const static uint threadCount = 1024;
#else
	const static uint threadCount = 256;
#endif

const static uint log2ThreadCount = firstbitlow(threadCount);

StructuredBuffer<uint> TotalInstanceCount, SortKeys;
uint BitIndex;

groupshared uint sharedSums[threadCount];

void PrefixSumSharedWrite(uint index, uint data)
{
	sharedSums[index] = data;
}

uint PrefixSumSharedRead(uint index)
{
	return sharedSums[index];
}

RWStructuredBuffer<uint> CountResult;
groupshared uint SharedCount;
groupshared uint SharedTotalInstanceCount;

[numthreads(threadCount, 1, 1)]
void RadixCount(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	if (!groupIndex)
	{
		SharedTotalInstanceCount = TotalInstanceCount[0];
		SharedCount = 0;
	}
	
	GroupMemoryBarrierWithGroupSync();
		
	// Count the elements for this block
	bool outOfRange = id >= SharedTotalInstanceCount;
	uint key = outOfRange ? 0xFFFFFFFF : SortKeys[id];
	bool bit = (key >> BitIndex) & 0x1;
	
	GroupMemoryBarrierWithGroupSync();
	
	if(!bit)
		InterlockedAdd(SharedCount, 1);
		
	GroupMemoryBarrierWithGroupSync();
	
	// Could write out the prefix sum results here.. but instead we just perform it again in the sort kernel
	// Write the final count out to global memory
	if (!groupIndex)
		CountResult[groupId] = SharedCount;
}

StructuredBuffer<uint> Count, TotalGroupCount;
RWStructuredBuffer<uint> ScanResult, TotalFalsesResult;
groupshared uint SharedGroupCount;

[numthreads(threadCount, 1, 1)]
void RadixScan(uint groupIndex : SV_GroupIndex)
{
	if(!groupIndex)
		SharedGroupCount = TotalGroupCount[0];
		
	GroupMemoryBarrierWithGroupSync();
	
	bool outOfRange = groupIndex >= SharedGroupCount;

	// Prefix sum the counts
	sharedSums[groupIndex] = outOfRange ? 0 : Count[groupIndex];
	
	uint totalFalses;
	PrefixSum(groupIndex, threadCount, log2ThreadCount, totalFalses);
	
	// Write the toal global number of falses
	if (!groupIndex)
		TotalFalsesResult[0] = totalFalses;
		
	GroupMemoryBarrierWithGroupSync();
	
	// Write the total prefix sum for each group
	ScanResult[groupIndex] = sharedSums[groupIndex];
}

RWStructuredBuffer<uint> ScatterDataResult, ScatterKeysResult;
StructuredBuffer<uint> ScatterData, TotalFalses, GroupScans;

groupshared uint sharedKeys[threadCount];
groupshared uint GroupScan;
groupshared uint SharedTotalFalses;

[numthreads(threadCount, 1, 1)]
void RadixScatter(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	if (!groupIndex)
	{
		SharedTotalInstanceCount = TotalInstanceCount[0];
		GroupScan = GroupScans[groupId];
		SharedTotalFalses = TotalFalses[0];
	}

	GroupMemoryBarrierWithGroupSync();
	
	// Count the elements for this block
	bool outOfRange = id >= SharedTotalInstanceCount;
	uint key = outOfRange ? 0xFFFFFFFF : SortKeys[id];
	bool bit = (key >> BitIndex) & 0x1;
	
	sharedSums[groupIndex] = !bit;
	
	PrefixSum(groupIndex, threadCount, log2ThreadCount);
	
	GroupMemoryBarrierWithGroupSync();
	
	uint i = id;
	uint f = sharedSums[groupIndex] + GroupScan;
	uint t = i - f + SharedTotalFalses;
	uint d = bit ? t : f;
	
	// Write final results
	ScatterDataResult[d] = ScatterData[id];
	ScatterKeysResult[d] = key;
}

#include "../../Math.hlsl"
#include "../../PrefixSum.hlsl"

#pragma kernel RadixCount COUNT
#pragma kernel RadixScan SCAN
#pragma kernel RadixScatter SCATTER
//#pragma enable_d3d11_debug_symbols

#ifdef SCAN
const static uint threadCount = 512;
#else
const static uint threadCount = 128;
#endif

RWStructuredBuffer<uint> KeysResult, DataResult, CountResult, TotalSumsResult, ScanResult;
StructuredBuffer<uint> Keys, Data, TotalGroupCount, GroupCounts, TotalSums, GroupScans;
uint BitIndex;

groupshared uint sharedSums[threadCount];
groupshared uint sharedSums4[threadCount];

cbuffer DataLength
{
	uint TotalLength;
	uint pad0;
	uint pad1;
	uint pad2;
};

void PrefixSumSharedWrite(uint index, uint data)
{
	sharedSums[index] = data;
}

uint PrefixSumSharedRead(uint index)
{
	return sharedSums[index];
}

void PrefixSumSharedWrite4(uint index, uint4 data)
{
	sharedSums4[index] = data;
}

uint4 PrefixSumSharedRead4(uint index)
{
	return sharedSums4[index];
}

const static uint BitsPerPass = 2;
const static uint Exp2BitsPerPass = 1 << BitsPerPass;
groupshared uint SharedSums[2][Exp2BitsPerPass]; // Double buffered, so two indices per element

[numthreads(threadCount, 1, 1)]
void RadixCount(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	// Count the elements for this block
	bool outOfRange = id >= TotalLength;
	uint key = outOfRange ? UintMax : Keys[id];
	uint data = outOfRange ? 0 : Data[id];
	uint value = (key >> BitIndex) & 0x3;
	
	// Count and sort
	uint4 packedValues = (value == uint4(0, 1, 2, 3)) << uint4(0, 8, 16, 24);
	uint packedValue = packedValues.x | packedValues.y | packedValues.z | packedValues.w;
	uint packedSum;
	uint packedOffset = PrefixSum(packedValue, groupIndex, threadCount, packedSum);
	
	// Unpack sums and offset
	uint4 offsets = (packedOffset >> uint4(0, 8, 16, 24)) & 0xFF;
	uint4 sums = (packedSum >> uint4(0, 8, 16, 24)) & 0xFF;
	
	// Prefix sum
	uint sum = 0;
	if (groupIndex < Exp2BitsPerPass)
	{
		sum = groupIndex ? sums[groupIndex - 1] : 0;
		SharedSums[0][groupIndex] = sum;
	}
	
	[unroll]
	for (uint i = 0; i < BitsPerPass; i++)
	{
		GroupMemoryBarrierWithGroupSync();
		
		if (groupIndex >= Exp2BitsPerPass)
			continue;
	
		uint offset = 1 << i;
		if (groupIndex >= offset)
			sum += SharedSums[i & 1][groupIndex - offset];
			
		SharedSums[!(i & 1)][groupIndex] = sum;
	}
	GroupMemoryBarrierWithGroupSync();
	
	uint d = offsets[value] + SharedSums[0][value];
	
	// Write to global memory
	KeysResult[groupId * threadCount + d] = key;
	DataResult[groupId * threadCount + d] = data;
	
	if (!groupIndex)
		CountResult[groupId] = packedSum;
		
	{
		uint value = (key >> BitIndex) & 0xF;
		uint4 packedValues[4];
		
		[unroll]
		for (uint i = 0; i < 4; i++)
			packedValues[i] = (value == (uint4(0, 4, 8, 12) + i)) << (i * 8);
	
		uint4 packedValue = packedValues[0] | packedValues[1] | packedValues[2] | packedValues[3];
		uint4 packedSum;
		uint4 packedOffset = PrefixSum(packedValue, groupIndex, threadCount, packedSum);
		
		// Unpack sums and offset
		uint4 offsets = (packedOffset >> uint4(0, 8, 16, 24)) & 0xFF;
		uint4 sums = (packedSum >> uint4(0, 8, 16, 24)) & 0xFF;
	}

}

[numthreads(threadCount, 1, 1)]
void RadixScan(uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	// Prefix sum the counts
	bool outOfRange = groupIndex >= TotalGroupCount[0];
	uint packedCount = outOfRange ? 0 : GroupCounts[groupIndex];
	uint4 counts = (packedCount >> uint4(0, 8, 16, 24)) & 0xFF;

	uint count = counts[groupId];
	uint sum;
	uint offset = PrefixSum(count, groupIndex, threadCount, sum);
	
	ScanResult[Exp2BitsPerPass * groupIndex + groupId] = offset;
	
	if (!groupIndex)
		TotalSumsResult[groupId] = sum;
}

[numthreads(threadCount, 1, 1)]
void RadixScatter(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	bool outOfRange = id >= TotalLength;
	uint key = outOfRange ? UintMax : Keys[id];
	uint data = outOfRange ? 0 : Data[id];
	uint value = (key >> BitIndex) & 0x3;
	
	uint packedLocalOffsets = GroupCounts[groupId];
	uint4 localOffsets = (packedLocalOffsets >> uint4(0, 8, 16, 24)) & 0xFF;
	
	// Prefix sum
	uint globalSum = 0;
	if (groupIndex < Exp2BitsPerPass)
	{
		// We need to compute the global offset for each digit from this group, this can be done with two prefix
		// scans, or alternatively, can be reformulated to one, hence the below complexity
		// TODO: Can this simplify further and avoid looking up groupscans twice
		globalSum = TotalSums[groupIndex - 1] + GroupScans[Exp2BitsPerPass * groupId + groupIndex];
		if (groupIndex)
			globalSum -= GroupScans[Exp2BitsPerPass * groupId + (groupIndex - 1)] + localOffsets[groupIndex - 1];
		
		SharedSums[0][groupIndex] = globalSum;
	}
	
	[unroll]
	for (uint i = 0; i < BitsPerPass; i++)
	{
		GroupMemoryBarrierWithGroupSync();
		if (groupIndex >= Exp2BitsPerPass)
			continue;
	
		uint offset = 1 << i;
		if (groupIndex >= offset)
			globalSum += SharedSums[i & 1][groupIndex - offset];
			
		SharedSums[!(i & 1)][groupIndex] = globalSum;
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	// Write final results
	uint globalDest = groupIndex + SharedSums[0][value];
	KeysResult[globalDest] = key;
	DataResult[globalDest] = data;
}

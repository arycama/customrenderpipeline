#include "../../PrefixSum.hlsl"

#pragma kernel InstanceSort

RWStructuredBuffer<uint> Result;
StructuredBuffer<uint> Input;
StructuredBuffer<uint> TotalInstanceCount, SortKeys;
RWStructuredBuffer<float> SortKeysWrite;

const static uint threadCount = 256;
const static uint log2ThreadCount = firstbitlow(threadCount);

groupshared uint sharedKeys[threadCount];
groupshared uint sharedIndices[threadCount];
groupshared uint histogram[threadCount];
groupshared uint histogram1[4];
groupshared uint4 prefixSum[threadCount];

void PrefixSumSharedWrite(uint index, uint data)
{
	histogram[index] = data;
}

uint PrefixSumSharedRead(uint index)
{
	return histogram[index];
}

[numthreads(threadCount, 1, 1)]
void InstanceSort(uint id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint groupId : SV_GroupID)
{
	bool outOfRange = id >= TotalInstanceCount[0];
	sharedKeys[groupIndex] = outOfRange ? 0xFFFFFFFF : SortKeys[id];
	sharedIndices[groupIndex] = groupIndex;
	
	[unroll]
	for (uint i = 0; i < 4; i++)
	{
		// Clear histogram
		histogram[groupIndex] = 0;
		
		GroupMemoryBarrierWithGroupSync();

		// Count occurrences of each digit
		uint srcIndex = sharedIndices[groupIndex];
		uint key = sharedKeys[srcIndex];
		uint digit = (key >> (8 * i)) & 0xFF;
		
		InterlockedAdd(histogram[digit], 1);
		PrefixSum(groupIndex, threadCount, log2ThreadCount);
		
		// Reorder elements to shared memory
		uint arraySum = 0;
		for (uint j = 0; j < groupIndex; j++)
			arraySum += ((sharedKeys[sharedIndices[j]] >> (8 * i)) & 0xFF) == digit;
	
		uint dstIndex = histogram[digit] + arraySum;
		
		GroupMemoryBarrierWithGroupSync();
		
		sharedIndices[dstIndex] = srcIndex;
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	// Write final results
	uint finalSrc = groupId * threadCount + sharedIndices[groupIndex];
	Result[id] = Input[finalSrc];
	//SortKeysWrite[id] = SortKeys[finalSrc];
}
#include "../Atmosphere.hlsl"
#include "../Common.hlsl"
#include "../Lighting.hlsl"
#include "../Random.hlsl"
#include "../Temporal.hlsl"
#include "../VolumetricLight.hlsl"

#pragma kernel Compute
#pragma kernel FilterX KERNEL=FilterX HORIZONTAL
#pragma kernel FilterY KERNEL=FilterY VERTICAL
#pragma kernel Accumulate

RWTexture3D<float4> Result;
Texture3D<float4> Input;

float4x4 PixelToWorldViewDir;
float3 InputScale, InputMax;

[numthreads(8, 8, 8)]
void Compute(uint3 id : SV_DispatchThreadID)
{
	float maxDepth = LinearEyeDepth(HiZMaxDepth.mips[VolumetricLog2TileSize][id.xy]);

	float jitter = Noise1D(id.xy);
	float3 worldDir = MultiplyVector(PixelToWorldViewDir, float3(id.xy + 0.5, 1.0));
	float rcpWorldDirLength = RcpLength(worldDir);
	worldDir *= rcpWorldDirLength;
	
	float linearUnjitteredDepth = VolumetricToLinearDepth(id.z + 0.5);
	if (maxDepth <= linearUnjitteredDepth)
	{
		// If depth is beyond, write 0 and return. (Must write out 0 for temporal to avoid reprojecting invalid data)
		Result[id] = float2(0, 1).xxxy;
		return;
	}
	
	float eyeDepth = VolumetricToLinearDepth(id.z + jitter);
	
	float viewDistance = eyeDepth * rcp(rcpWorldDirLength);
	float3 worldPosition = worldDir * viewDistance;
	
	float2 positionNDC = (id.xy + 0.5) / float2(VolumeWidth, VolumeHeight);
	float2 pixelPosition = positionNDC * ViewSize;
	
	uint3 clusterIndex;
	clusterIndex.xy = floor(pixelPosition) / TileSize;
	clusterIndex.z = log2(eyeDepth) * ClusterScale + ClusterBias;
	
	uint2 lightOffsetAndCount = LightClusterIndices[clusterIndex];
	
	// Point lights TODO: Combine with common lighting code
	float3 lighting = 0.0;
	for (uint i = 0; i < min(128, lightOffsetAndCount.y); i++)
	{
		LightData light = PointLights[LightClusterList[lightOffsetAndCount.x + i]];
		
		float3 lightVector = light.position - worldPosition;
		float sqrLightDist = dot(lightVector, lightVector);
		if (sqrLightDist >= Sq(light.range))
			continue;
		
		float rcpLightDist = rsqrt(sqrLightDist);
		float3 L = lightVector * rcpLightDist;

		float attenuation = GetLightAttenuation(light, worldPosition, 0.5, false);
		float3 scatter = AtmosphereScatter(ViewHeight, worldDir.y, viewDistance, dot(L, worldDir));
		lighting += attenuation * Exposure * scatter * light.color;
	}
	
	// TODO: Ensure extinction is premultiplied by log2e
	float4 luminanceExtinction = float4(lighting, 0.0);
	
	// Reproject previous frame. Needs to use unjittered world position
	float4 clipPosition;
	clipPosition.w = linearUnjitteredDepth;
	clipPosition.xy = (positionNDC * 2.0 - 1.0) * clipPosition.w;
	clipPosition.z = LinearToDeviceDepth(clipPosition.w) * clipPosition.w;
	
	// TODO: Could do screen to previous screen to save a few instructions
	float4 previousClipPosition = mul(ClipToPreviousClip, clipPosition);
	previousClipPosition.xy = PerspectiveDivide(previousClipPosition).xy * 0.5 + 0.5;
	
	float3 volumeUv = float3(previousClipPosition.xy, LinearToVolumetricDepth(previousClipPosition.w));
	if (all(saturate(volumeUv) == volumeUv))
	{
		// TODO: Neighborood clamp? (May be expensive, probably best to combien with groupshared
		float4 previousLuminanceExtinction = Input.SampleLevel(TrilinearClampSampler, min(volumeUv * InputScale, InputMax), 0.0);
		luminanceExtinction = lerp(previousLuminanceExtinction, luminanceExtinction, 0.2);
	}
	
	Result[id] = luminanceExtinction;
}

[numthreads(8, 8, 8)]
void KERNEL(uint3 id : SV_DispatchThreadID)
{
	float maxDepth = LinearEyeDepth(HiZMaxDepth.mips[VolumetricLog2TileSize][id.xy]);
	float linearUnjitteredDepth = VolumetricToLinearDepth(id.z + 0.5);
	//if (maxDepth <= linearUnjitteredDepth)
	//	return;
	
	float4 result = 0.0;
	float weightSum = 0.0;
	
	int radius = 2;
	for (int i = -radius; i <= radius; i++)
	{
		#ifdef HORIZONTAL
			int3 coord = id + int3(i, 0, 0);
		#else
			int3 coord = id + int3(0, i, 0);
		#endif
		
		if (any(coord < 0 || coord >= int3(VolumeWidth, VolumeHeight, VolumeDepth)))
			continue;
		
		float4 luminanceExtinction = Input[coord];
		float weight = exp(-Sq(i / VolumetricBlurSigma));
		result += luminanceExtinction * weight;
		weightSum += weight;
	}
	
	if (weightSum > 0.0)
		result /= weightSum;
	
	Result[id] = result;
}

[numthreads(8, 4, 1)]
void Accumulate(uint2 id : SV_DispatchThreadID)
{
	float maxDepth = LinearEyeDepth(HiZMaxDepth.mips[VolumetricLog2TileSize][id]);

	float3 worldDir = MultiplyVector(PixelToWorldViewDir, float3(id.xy + 0.5, 1.0));
	float rcpWorldDirLength = RcpLength(worldDir);
	worldDir *= rcpWorldDirLength;
	float worldDirLength = rcp(rcpWorldDirLength);
	
	float3 transmittance = 1.0;
	float4 result = float2(0.0, 1.0).xxxy;
	for (uint i = 0; i < VolumeDepth; i++)
	{
		float t0 = VolumetricToLinearDepth(i + 0);
		float t1 = VolumetricToLinearDepth(i + 1);
		if (maxDepth < t0)
		{
			Result[uint3(id, i)] = float2(0.0, 1.0).xxxy;
			continue;
		}
			
		t0 *= worldDirLength;
		t1 *= worldDirLength;
		
		float t = lerp(t0, t1, 0.5);
		float ds = t1 - t0;
	
		// Attenuate due to atmosphere and local extinction
		float4 luminanceExtinction = Input[uint3(id.xy, i)];
		float3 sampleExtinction = AtmosphereExtinction(ViewHeight, worldDir.y, t) + luminanceExtinction.a;
		float3 sampleTransmittance = exp(-sampleExtinction * ds);
		
		result.rgb += transmittance * luminanceExtinction.rgb * (1.0 - sampleTransmittance) * rcp(sampleExtinction);
		transmittance *= sampleTransmittance;
		result.a *= exp(-luminanceExtinction.a * ds); // Accumulate result.a seperately as we don't want to apply atmospheric transmittance twice
		Result[uint3(id, i)] = result;
	}
}

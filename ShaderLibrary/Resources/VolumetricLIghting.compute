#include "../Atmosphere.hlsl"
#include "../Common.hlsl"
#include "../Lighting.hlsl"
#include "../VolumetricLight.hlsl"

#pragma kernel Compute
#pragma kernel FilterX KERNEL=FilterX HORIZONTAL
#pragma kernel FilterY KERNEL=FilterY VERTICAL
#pragma kernel Accumulate

RWTexture3D<float4> _Result;
Texture3D<float4> _Input;

float4x4 _PixelToWorldViewDir, _PixelToWorldViewDir1;
uint _VolumeTileSize;
float _BlurSigma;
float _VolumeWidth;
float _VolumeHeight;

[numthreads(8, 8, 8)]
void Compute(uint3 id : SV_DispatchThreadID)
{
	float2 positionNDC = (id.xy + 0.5) / float2(_VolumeWidth, _VolumeHeight);
	float2 pixelPosition = positionNDC * _ScaledResolution.xy;
	float3 V = -MultiplyVector(_PixelToWorldViewDir, float3(pixelPosition, 1.0), true);
	
	float jitter = 0.5;//_BlueNoise1D[id.xy % 128];
	
	float normalizedDepth = (id.z + jitter) / _VolumeSlices;
	float eyeDepth = lerp(_VolumetricLightNear, _VolumetricLightFar, normalizedDepth);
	
	float3 positionCS;
	positionCS.xy = positionNDC * 2.0 - 1.0;
	positionCS.z = Linear01ToDeviceDepth(Remap(eyeDepth, _Near, _Far));
	
	float3 worldPosition = ClipToWorld(positionCS.xyz);
	float3 lighting = 0.0;
	
	//float3 V = -normalize(worldPosition);
	float viewDistance = length(worldPosition);
	
	float viewHeight = _ViewPosition.y + _PlanetRadius;
	float height = HeightAtDistance(viewHeight, -V.y, viewDistance);
	
	uint3 clusterIndex;
	clusterIndex.xy = floor(pixelPosition) / _TileSize;
	clusterIndex.z = log2(eyeDepth) * _ClusterScale + _ClusterBias;
	
	uint2 lightOffsetAndCount = _LightClusterIndices[clusterIndex];
	uint startOffset = lightOffsetAndCount.x;
	uint lightCount = lightOffsetAndCount.y;
	
	// Point lights
	for (uint i = 0; i < min(128, lightCount); i++)
	{
		int index = _LightClusterList[startOffset + i];
		PointLight light = _PointLights[index];
		
		float3 lightVector = light.position - worldPosition;
		float sqrLightDist = dot(lightVector, lightVector);
		if(sqrLightDist > Sq(light.range))
			continue;
		
		sqrLightDist = max(Sq(0.01), sqrLightDist);
		float rcpLightDist = rsqrt(sqrLightDist);
		
		float3 L = lightVector * rcpLightDist;

		float attenuation = 1;// CalculateLightFalloff(rcpLightDist, sqrLightDist, rcp(Sq(light.range)));
		if(!attenuation)
			continue;
		
		float3 intensity = AtmosphereScatter(height, dot(L, -V));
		if(all(!intensity))
			continue;
			
		if(light.shadowIndex != ~0u)
		{
			uint visibleFaces = light.visibleFaces;
			float dominantAxis = Max3(abs(lightVector));
			float depth = rcp(dominantAxis) * light.far + light.near;
			//attenuation *= _PointShadows.SampleCmpLevelZero(_LinearClampCompareSampler, float4(lightVector * float3(-1, 1, -1), light.shadowIndex), depth);
			//if(!attenuation)
			//	continue;
		}
		
		lighting += (attenuation * _Exposure) * (intensity * light.color);
	}
	
	float4 luminanceExtinction = float4(lighting, 0.0);
	
	// Reproject previous frame. Needs to use unjittered world position
	float unjitteredNormalizedDepth = (id.z + 0.5) / _VolumeSlices;
	
	float4 unjitteredPositionCS;
	unjitteredPositionCS.xy = positionNDC * 2.0 - 1.0;
	unjitteredPositionCS.z = Linear01ToDeviceDepth(unjitteredNormalizedDepth);
	unjitteredPositionCS.w = Remap(unjitteredNormalizedDepth, 0.0, 1.0, _Near, _Far);
	
	float3 unjitteredPositionWS = ClipToWorld(unjitteredPositionCS.xyz);
	
	float4 prevPositionCS = PerspectiveDivide(WorldToClipPrevious(unjitteredPositionWS));
	prevPositionCS.xy = 0.5 * prevPositionCS.xy + 0.5;
	
	float3 volumeUv = float3(prevPositionCS.xy, GetVolumetricUv(prevPositionCS.w));

	if (all(saturate(volumeUv) == volumeUv))
	{
		float4 previousLuminanceExtinction = _Input.SampleLevel(_LinearClampSampler, volumeUv, 0.0);
		//luminanceExtinction = lerp(previousLuminanceExtinction, luminanceExtinction, 0.05);
	}
	
	_Result[id] = luminanceExtinction;
}

[numthreads(8, 8, 8)]
void KERNEL(uint3 id : SV_DispatchThreadID)
{
	float4 result = 0.0;
	float weightSum = 0.0;
	
	int radius = 2;
	for (int i = -radius; i <= radius; i++)
	{
		#ifdef HORIZONTAL
			int3 coord = id + int3(i, 0, 0);
		#else
			int3 coord = id + int3(0, i, 0);
		#endif
		
		if (any(coord < 0 || coord >= int3(_VolumeWidth, _VolumeHeight, _VolumeSlices)))
			continue;
		
		float4 luminanceExtinction = _Input[coord];
		float weight = exp(-Sq(i / _BlurSigma));
		result += luminanceExtinction * weight;
		weightSum += weight;
	}
	
	if (weightSum > 0.0)
		result /= weightSum;
	
	_Result[id] = result;
}

[numthreads(8, 8, 1)]
void Accumulate(uint2 id : SV_DispatchThreadID)
{
	float3 V = MultiplyVector(_PixelToWorldViewDir, float3(id + 0.5, 1.0), true);
	
	float startT = CameraDepthToDistance(_VolumetricLightNear, V);
	float endT = CameraDepthToDistance(_VolumetricLightFar, V);
	
	float rayLength = endT - startT;
	
	float ds = rayLength / _VolumeSlices;
	
	float4 result = float2(0.0, 1.0).xxxy;
	for (uint i = 0; i < uint(_VolumeSlices); i++)
	{
		float4 luminanceExtinction = _Input[uint3(id.xy, i)];
		float transmittance = exp(-luminanceExtinction.a * ds);
		
		result.rgb += result.a * luminanceExtinction.rgb;
		result.a *= transmittance;
		_Result[uint3(id, i)] = result;
	}
}
#include "../Atmosphere.hlsl"
#include "../Common.hlsl"
#include "../Lighting.hlsl"
#include "../VolumetricLight.hlsl"

#pragma kernel Compute
#pragma kernel FilterX KERNEL=FilterX HORIZONTAL
#pragma kernel FilterY KERNEL=FilterY VERTICAL
#pragma kernel Accumulate

RWTexture3D<float4> _Result;
Texture3D<float4> _Input;

float4x4 _PixelToWorldViewDir;
uint _VolumeTileSize;
float _BlurSigma;
float _VolumeWidth;
float _VolumeHeight;
float3 _InputScale, _InputMax;

[numthreads(8, 8, 8)]
void Compute(uint3 id : SV_DispatchThreadID)
{
	float jitter = _BlueNoise1D[id.xy % 128];
	float3 worldDir = MultiplyVector(_PixelToWorldViewDir, float3(id.xy + 0.5, 1.0), false);
	float rcpWorldDirLength = rsqrt(dot(worldDir, worldDir));
	worldDir *= rcpWorldDirLength;
	
	float eyeDepth = lerp(_VolumetricLightNear, _VolumetricLightFar, (id.z + jitter) / _VolumeSlices);
	float viewDistance = eyeDepth * rcp(rcpWorldDirLength);
	float3 worldPosition = worldDir * viewDistance;
	
	float height = HeightAtDistance(_ViewHeight, worldDir.y, viewDistance);
	
	float2 positionNDC = (id.xy + 0.5) / float2(_VolumeWidth, _VolumeHeight);
	float2 pixelPosition = positionNDC * _ScaledResolution.xy;
	
	uint3 clusterIndex;
	clusterIndex.xy = floor(pixelPosition) / _TileSize;
	clusterIndex.z = log2(eyeDepth) * _ClusterScale + _ClusterBias;
	
	uint2 lightOffsetAndCount = _LightClusterIndices[clusterIndex];
	
	// Point lights
	float3 lighting = 0.0;
	for (uint i = 0; i < min(128, lightOffsetAndCount.y); i++)
	{
		PointLight light = _PointLights[_LightClusterList[lightOffsetAndCount.x + i]];
		
		float3 lightVector = light.position - worldPosition;
		float sqrLightDist = dot(lightVector, lightVector);
		if(sqrLightDist > Sq(light.range))
			continue;
		
		sqrLightDist = max(Sq(0.01), sqrLightDist);
		float rcpLightDist = rsqrt(sqrLightDist);
		
		float3 L = lightVector * rcpLightDist;

		float attenuation = CalculateLightFalloff(rcpLightDist, sqrLightDist, rcp(Sq(light.range)));
		if(!attenuation)
			continue;
		
		float3 intensity = AtmosphereScatter(height, dot(L, worldDir));
		if(all(!intensity))
			continue;
			
		if(light.shadowIndex != ~0u)
		{
			uint visibleFaces = light.visibleFaces;
			float dominantAxis = Max3(abs(lightVector));
			float depth = rcp(dominantAxis) * light.far + light.near;
			attenuation *= _PointShadows.SampleCmpLevelZero(_LinearClampCompareSampler, float4(lightVector * float3(-1, 1, -1), light.shadowIndex), depth);
			if(!attenuation)
				continue;
		}
		
		lighting += (attenuation * _Exposure) * (intensity * light.color);
	}
	
	float4 luminanceExtinction = float4(lighting, 0.0);
	
	// Reproject previous frame. Needs to use unjittered world position
	float3 unjitteredPositionCS;
	unjitteredPositionCS.xy = positionNDC * 2.0 - 1.0;
	unjitteredPositionCS.z = EyeToDeviceDepth(lerp(_VolumetricLightNear, _VolumetricLightFar, (id.z + 0.5) / _VolumeSlices));
	
	float4 prevPositionCS = PerspectiveDivide(WorldToClipPrevious(ClipToWorld(unjitteredPositionCS)));
	prevPositionCS.xy = 0.5 * prevPositionCS.xy + 0.5;
	
	float3 volumeUv = float3(prevPositionCS.xy, GetVolumetricUv(prevPositionCS.w));

	if (all(saturate(volumeUv) == volumeUv))
	{
		float4 previousLuminanceExtinction = _Input.SampleLevel(_LinearClampSampler, min(volumeUv * _InputScale, _InputMax), 0.0);
		luminanceExtinction = lerp(previousLuminanceExtinction, luminanceExtinction, 0.05);
	}
	
	_Result[id] = luminanceExtinction;
}

[numthreads(8, 8, 8)]
void KERNEL(uint3 id : SV_DispatchThreadID)
{
	float4 result = 0.0;
	float weightSum = 0.0;
	
	int radius = 2;
	for (int i = -radius; i <= radius; i++)
	{
		#ifdef HORIZONTAL
			int3 coord = id + int3(i, 0, 0);
		#else
			int3 coord = id + int3(0, i, 0);
		#endif
		
		if (any(coord < 0 || coord >= int3(_VolumeWidth, _VolumeHeight, _VolumeSlices)))
			continue;
		
		float4 luminanceExtinction = _Input[coord];
		float weight = exp(-Sq(i / _BlurSigma));
		result += luminanceExtinction * weight;
		weightSum += weight;
	}
	
	if (weightSum > 0.0)
		result /= weightSum;
	
	_Result[id] = result;
}

[numthreads(8, 8, 1)]
void Accumulate(uint2 id : SV_DispatchThreadID)
{
	float3 worldDir = MultiplyVector(_PixelToWorldViewDir, float3(id.xy + 0.5, 1.0), false);
	float rayLength = (_VolumetricLightFar - _VolumetricLightNear) * length(worldDir);
	
	float ds = rayLength / _VolumeSlices;
	
	float4 result = float2(0.0, 1.0).xxxy;
	for (uint i = 0; i < uint(_VolumeSlices); i++)
	{
		float4 luminanceExtinction = _Input[uint3(id.xy, i)];
		float transmittance = exp(-luminanceExtinction.a * ds);
		
		result.rgb += result.a * luminanceExtinction.rgb;
		result.a *= transmittance;
		_Result[uint3(id, i)] = result;
	}
}
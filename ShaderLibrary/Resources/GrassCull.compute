#include "../Common.hlsl"
#include "../Geometry.hlsl"
#include "../MatrixUtils.hlsl"
#include "../TerrainCommon.hlsl"

#pragma kernel InstanceCull FIRST
#pragma kernel InstanceCull
#pragma kernel InstanceCull LAST
#pragma kernel IndirectArgs
#pragma kernel FillHistoPyramidBase
#pragma kernel BuildHistoPyramid

#pragma multi_compile _ HI_Z_CULL

struct InstanceData
{
	float3 center;
	float lod;
	float3 extents;
	float lodFactor;
};

AppendStructuredBuffer<InstanceData> _SubdividePatches;
AppendStructuredBuffer<InstanceData> _FinalPatchesWrite;
ConsumeStructuredBuffer<InstanceData> _InputPatches;
Texture2D<float2> _TerrainHeights;
RWBuffer<uint> _IndirectArgs;

float3 _PatchExtents;
float _EdgeLength, _MaxMip;
Buffer<uint> _ElementCount;
float _MaxHiZMip;

// If we wanted to avoid atomics, we could do this later with a parallel reduce, probably not worth it though
globallycoherent RWBuffer<uint> _LodCounts;
globallycoherent RWBuffer<uint> _LodCountIndex;
RWTexture2D<float> _LodMap;

float3 _BoundsCenter, _BoundsExtents;

struct Bounds
{
	float3 min;
	float pad0;
	float3 size;
	float pad1;
};

RWStructuredBuffer<Bounds> _BoundsData;

bool HiZCull(float3 boundsCenter, float3 boundsExtents)
{
	float3 screenMin, screenMax;
	
	[unroll]
	for (uint z = 0, i = 0; z < 2; z++, i++)
	{
		[unroll]
		for (uint y = 0; y < 2; y++, i++)
		{
			[unroll]
			for (uint x = 0; x < 2; x++, i++)
			{
				float3 worldPosition = boundsCenter - boundsExtents + boundsExtents * 2 * float3(x, y, z);
				float3 screenPosition = MultiplyPointProj(WorldToScreen, worldPosition).xyz;
				screenMin = i ? min(screenMin, screenPosition) : screenPosition;
				screenMax = i ? max(screenMax, screenPosition) : screenPosition;
			}
		}
	}
	
	// Calculate hi-Z buffer mip https://interplayoflight.wordpress.com/2017/11/15/experiments-in-gpu-based-occlusion-culling/
	float2 size = (screenMax - screenMin).xy * ViewSize;
	float mip = ceil(log2(Max2(size)));
 
	// If object bounds is larger than entire screen, we can't conservatively reject it, so return visible
	if (mip > _MaxHiZMip)
		return true;
		
	if (mip > 0.0)
	{
		// Texel footprint for the lower (finer-grained) level
		float levelLower = mip - 1.0;
		float2 scale = exp2(-levelLower);
		float2 a = floor(screenMin.xy * scale);
		float2 b = ceil(screenMax.xy * scale);
 
		// Use the lower level if we only touch <= 2 texels in both dimensions
		if (all(b - a <= 2.0))
			mip = levelLower;
	}
	else
		mip = 0.0;
		
	// Check if this aabb will actually generate any pixels (Eg overlap the center of the target pixel
	#if 0
		if (any(round(screenMin.xy * ViewSize) == round(screenMax.xy * ViewSize)))
			return false;
	#elif 0
		if (mip == 0.0)
		{
			float2 screenCenter = 0.5 * (screenMax + screenMin).xy;
			float2 pixelCenter = floor(screenCenter) + 0.5;
		
			if (any(pixelCenter < screenMin.xy || pixelCenter > screenMax.xy))
				return false;
		}
	#endif
	
	float2 mipRes = floor(ViewSize * exp2(-mip));
	float4 screenMinMax = float4(screenMin.xy, screenMax.xy) * mipRes.xyxy;
	screenMinMax = clamp(screenMinMax, 0, mipRes.xyxy - 1);
		
	return screenMax.z > HiZMaxDepth.mips[mip][screenMinMax.xy] ||
		screenMax.z > HiZMaxDepth.mips[mip][screenMinMax.zy] ||
		screenMax.z > HiZMaxDepth.mips[mip][screenMinMax.xw] ||
		screenMax.z > HiZMaxDepth.mips[mip][screenMinMax.zw];
}

[numthreads(64, 1, 1)]
void InstanceCull(uint id : SV_DispatchThreadID)
{
	#ifdef FIRST
		// Out of bounds check
		if (id >= 1)
			return;
	
		float3 center = _BoundsCenter - ViewPosition;
		float3 extents = _BoundsExtents;
	#else
		// Out of bounds check
		uint elementCount = _ElementCount[0];
		if (id >= elementCount)
			return;
	
		InstanceData instanceData = _InputPatches.Consume();
		float3 extents = instanceData.extents;
		float3 center = instanceData.center;
	#endif
	
	//if (!FrustumCull(center, extents))
	//	return;
	
	#ifdef HI_Z_CULL
		if(!HiZCull(center, extents))
			return;
	#endif
	
	// Lod calculation
	float radius = length(extents);
	float factor = CalculateSphereEdgeFactor(radius, center, _EdgeLength, rcp(TanHalfFov), ViewSize.y);
	float lodLevel = log2(rcp(factor));
	float lodFactor = 1.0 - frac(lodLevel);
	float lod = floor(lodLevel);
	
	float2 terrainResolution;
	_TerrainHeights.GetDimensions(terrainResolution.x, terrainResolution.y);
	
	#ifndef LAST
		if (lod < 0)
		{
			float3 offsets[4] = { float3(-0.5, 0.0, -0.5), float3(0.5, 0.0, -0.5), float3(-0.5, 0.0, 0.5), float3(0.5, 0.0, 0.5) };
		
			// Sphere is larger than max lod, add to list so it can be subdivided
			// Divide into four leaf nodes and add each one
			[unroll]
			for (uint i = 0; i < 4; i++)
			{
				float3 size = extents * float3(1, 2, 1);
				float3 position = center + size * offsets[i];
			
				// Need min and max XZ in terrain space, transform min and max corners
				float2 mipFactor = size.xz / TerrainSize.xz * terrainResolution;
				float deltaMaxSqr = max(mipFactor.x, mipFactor.y);
				float mip = ceil(log2(deltaMaxSqr));
	
				float2 terrainPosition = WorldToTerrainPosition(position - ViewPosition);
				float2 terrainUv = Remap01ToHalfTexel(terrainPosition, terrainResolution);
	
				float2 heights = _TerrainHeights.SampleLevel(PointClampSampler, terrainUv, mip).gr;
				size.y = heights.y - heights.x + _PatchExtents.y * 2;
				position.y = heights.x + size.y * 0.5;
			
				InstanceData data;
				data.center = position;
				data.lod = lod;
				data.extents = size * 0.5;
				data.lodFactor = lodFactor;
				_SubdividePatches.Append(data);
			}
		}
		else
	#else
		if(lod < 0)
		{
			lod = 0;
			lodFactor = 1.0;
		}
	#endif
	{
		InstanceData data;
		data.center = center;
		data.lod = lod;
		data.extents = extents;
		data.lodFactor = lodFactor;

		// correct lod, write position and size to list
		_FinalPatchesWrite.Append(data);
		
		// Also increment the relevant lod counter
		//InterlockedAdd(_LodCounts[lod], 1);
	}
}

[numthreads(1, 1, 1)]
void IndirectArgs(uint id : SV_DispatchThreadID)
{
	_IndirectArgs[0] = ceil(_IndirectArgs[0] / 64.0);
}

StructuredBuffer<InstanceData> _HistoPyramidInputs;
RWStructuredBuffer<uint> _HistoPyramidOutput;
StructuredBuffer<uint> _HistoPyramidInput;
float _MaxLod;
uint _MaxElement;

[numthreads(64, 1, 1)]
void FillHistoPyramidBase(uint id : SV_DispatchThreadID)
{
	if (id > _MaxElement)
		return;
	
	InstanceData data = _HistoPyramidInputs[id];
	_HistoPyramidOutput[id] = exp2(_MaxLod - data.lod);
}

uint _StartOffset;
uint _DstOffset;

[numthreads(64, 1, 1)]
void BuildHistoPyramid(uint id : SV_DispatchThreadID)
{
	if (id > _MaxElement)
		return;
	
	uint element0 = _HistoPyramidOutput[_StartOffset + 2 * id + 0];
	uint element1 = _HistoPyramidOutput[_StartOffset + 2 * id + 1];
	_HistoPyramidOutput[_DstOffset + id] = element0 + element1;
}

uint _MaxLevel;

[numthreads(64, 1, 1)]
void TraverseHistoPyramid(uint id : SV_DispatchThreadID)
{
	uint key = id;
	
	for (uint i = 0; i < _MaxLevel; i++)
	{
		
	}

}
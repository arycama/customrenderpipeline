#include "../../Color.hlsl"
#include "../../Common.hlsl"
#include "../../Exposure.hlsl"
#include "../../PhysicalCamera.hlsl"
#include "../../Samplers.hlsl"

#pragma kernel LuminanceBuildHistogram
#pragma kernel LuminanceHistogramAverage

static const uint HistogramBins = 256;
static const uint SqrtHistogramBins = sqrt(HistogramBins);

Texture2D<float3> Input;
Texture2D<float> ExposureCompensationTexture;
RWStructuredBuffer<uint> LuminanceHistogram;
RWStructuredBuffer<float4> LuminanceOutput;

cbuffer Properties
{
	float MinEv, MaxEv;
	float AdaptationSpeed;
	float ExposureCompensation;
	float Aperture, Iso, ShutterSpeed;
	float HistogramMin, HistogramMax;
	float IsFirst, Mode;
	float MeteringMode;
	float2 ProceduralCenter, ProceduralRadii;
	float ProceduralSoftness;
	float PropertiesPadding0;
	float PropertiesPadding1;
	float PropertiesPadding2;
};

groupshared uint HistogramShared[HistogramBins];

[numthreads(SqrtHistogramBins, SqrtHistogramBins, 1)]
void LuminanceBuildHistogram(uint groupIndex : SV_GroupIndex, uint2 threadId : SV_DispatchThreadID)
{
	HistogramShared[groupIndex] = 0;
    
	GroupMemoryBarrierWithGroupSync();
    
	if (all(threadId <= ViewSizeMinusOne))
	{
		float3 color = Input[threadId];
		float luminance = Rec2020Luminance(color) * RcpExposure;
		
		if (IsInfOrNaN(luminance))
			luminance = 0;
			
		float ev100 = LuminanceToEV100(luminance);
		ev100 = clamp(ev100, MinEv, MaxEv);
		
		uint binIndex = luminance ? round(Remap(ev100, MinEv, MaxEv, 1.0, 255.0)) : 0;
		InterlockedAdd(HistogramShared[binIndex], 1);
	}
    
	GroupMemoryBarrierWithGroupSync();

	if (any(threadId > ViewSizeMinusOne))
		return;
	
	InterlockedAdd(LuminanceHistogram[groupIndex], HistogramShared[groupIndex]);
}

[numthreads(HistogramBins, 1, 1)]
void LuminanceHistogramAverage(uint groupIndex : SV_GroupIndex)
{
	uint countForThisBin = LuminanceHistogram[groupIndex];
	LuminanceHistogram[groupIndex] = 0;
	HistogramShared[groupIndex] = countForThisBin * groupIndex;
	
    [unroll]
	for (uint i = HistogramBins >> 1; i > 0; i >>= 1)
	{
		GroupMemoryBarrierWithGroupSync();
	
		if (groupIndex < i)
			HistogramShared[groupIndex] += HistogramShared[groupIndex + i];
	}
    
	if (groupIndex)
		return;
	
	float pixelCount = ViewSize.x * ViewSize.y;
	float weightedLogAverage = HistogramShared[0] / max(pixelCount - float(countForThisBin), 1.0);
	float averageEv = Remap(weightedLogAverage, 1.0, 255.0, MinEv, MaxEv);
	float previousExposure = Exposure;
	float previousEv = ExposureToEV100(previousExposure) + PreviousExposureCompensation;
	float adaptedEv = lerp(averageEv, previousEv, exp(-RenderDeltaTime * AdaptationSpeed));
	
	//adaptedEv = averageEv;
	adaptedEv = clamp(adaptedEv, MinEv, MaxEv);
	
	if (Mode == 1.0)
		adaptedEv = ComputeEV100(Aperture, ShutterSpeed, Iso);
		
	float exposureCompensation = ExposureCompensation;
	
	//float k = adaptedLuminance > 0.0 ? 1.03 - 2.0 * rcp(log10(adaptedLuminance + 1.0) + 2.0) : 1.0;
	//exposureCompensation += LuminanceToEV100(k * LensImperfectionExposureScale);
	
	float2 uv = Remap(adaptedEv, MinEv, MaxEv);
	exposureCompensation += ExposureCompensationTexture.SampleLevel(LinearClampSampler, float2(uv.x, 0.5), 0.0);
	
	float currentExposure = EV100ToExposure(adaptedEv - exposureCompensation);
	
	if (IsFirst || IsInfOrNaN(currentExposure) || currentExposure == 0.0)
		currentExposure = 1.0;
	
	if (previousExposure == 0.0 || IsInfOrNaN(previousExposure))
		previousExposure = 1.0;
	
	LuminanceOutput[0] = float4(currentExposure, rcp(currentExposure), currentExposure * rcp(previousExposure), exposureCompensation);
}
#include "../Common.hlsl"
#include "../Atmosphere.hlsl"
#include "../Lighting.hlsl"
#include "../CloudCommon.hlsl"

#pragma kernel CloudCoverage

RWBuffer<float4> _Result;

static const uint _ThreadCount = 1024;

groupshared float4 _SharedLuminanceExtinction[_ThreadCount];
float IsFirst;

[numthreads(1024, 1, 1)]
void CloudCoverage(uint groupIndex : SV_GroupIndex)
{
	float2 uv = Hammersley2dSeq(groupIndex, _ThreadCount);
	float sampleCount = _ThreadCount;
	float3 V = SampleHemisphereUniform(uv.x, uv.y).xzy;

	float rayStart = DistanceToSphereInside(_PlanetRadius, V.y, _PlanetRadius + _StartHeight);
	float rayEnd = DistanceToSphereInside(_PlanetRadius, V.y, _PlanetRadius + _StartHeight + _LayerThickness);
	
	float cloudDistance;
	float4 clouds = EvaluateCloud(rayStart, rayEnd - rayStart, 16, V, _PlanetRadius, V.y, 0.5, float3(0.0, -ViewPosition.y, 0.0), false, cloudDistance, false);
	
	_SharedLuminanceExtinction[groupIndex] = clouds / sampleCount;
	
	[unroll]
	for (uint s = _ThreadCount >> 1; s > 0; s >>= 1)
	{
		GroupMemoryBarrierWithGroupSync();
		
		if (groupIndex < s)
			_SharedLuminanceExtinction[groupIndex] = _SharedLuminanceExtinction[groupIndex] + _SharedLuminanceExtinction[groupIndex + s];
	}
	
	if (groupIndex)
		return;
	
	float4 result = _SharedLuminanceExtinction[0];
	
	if (!IsFirst)
		result = lerp(_CloudCoverage, result, 0.05);
	
	// TODO: Need to figure out why this happens and fix it
	result = IsInfOrNaN(result) ? float2(0.0, 1.0).xxxy : result;
	
	// Smooth results over time to avoid flickering
	_Result[0] = result;
}

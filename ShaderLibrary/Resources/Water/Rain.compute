#include "Packages/com.arycama.customrenderpipeline/ShaderLibrary/Common.hlsl"
#include "Packages/com.arycama.customrenderpipeline/ShaderLibrary/Geometry.hlsl"
#include "Packages/com.arycama.customrenderpipeline/ShaderLibrary/Math.hlsl"
#include "Packages/com.arycama.customrenderpipeline/ShaderLibrary/Random.hlsl"

#pragma kernel Initialize
#pragma kernel Update

RWStructuredBuffer<float4> Positions;

uint RainDropletCount;
float RainRadius, RainVelocity, WindAngle, WindStrength, WindTurbulence;

float3 UniformPointInSphere(float3 random)
{
	// Generate random direction
	float theta = random.x * 2.0 * TwoPi;
	float phi = FastACos(2.0 * random.y - 1.0);
	float r = pow(random.z, 1.0 / 3.0); // Cube root for uniform volume distribution
    
    // Convert spherical to Cartesian coordinates
	float sinPhi = sin(phi);
	float x = r * sinPhi * cos(theta);
	float y = r * sinPhi * sin(theta);
	float z = r * cos(phi);
    
	return float3(x, y, z);
}

[numthreads(1024, 1, 1)]
void Initialize(uint id : SV_DispatchThreadID)
{
	if(id > RainDropletCount)
		return;

	float4 random = RandomFloat4(id);
	Positions[id] = float4(UniformPointInSphere(random.xyz) * RainRadius, lerp(-WindTurbulence, WindTurbulence, random.w)); //w component used for turbulence
}

[numthreads(1024, 1, 1)]
void Update(uint id : SV_DispatchThreadID)
{
	if (id > RainDropletCount)
		return;
		
	float4 positionTurbulence = Positions[id];
	float3 position = positionTurbulence.xyz;
	float turbulence = positionTurbulence.w;
	
	float2 windAngle;
	sincos(TwoPi * WindAngle + turbulence, windAngle.y, windAngle.x);
	
	float3 windVector = float3(windAngle * WindStrength, -RainVelocity).xzy;
	position += DeltaTime * windVector;

	if (SqrLength(position) > Sq(RainRadius))
	{
		float4 random = RandomFloat4(id);
		position = UniformPointInSphere(random.xyz) * RainRadius;
		turbulence = lerp(-WindTurbulence, WindTurbulence, random.w); //w component used for turbulence
	}
	
	float3 viewDelta = ViewPosition - PreviousViewPosition;
	position -= viewDelta;

	Positions[id] = float4(position, turbulence);
}

#include "../../Common.hlsl"
#include "../../GBuffer.hlsl"
#include "../../Random.hlsl"
#include "../../Samplers.hlsl"
#include "../../Lighting.hlsl"
#include "../../ImageBasedLighting.hlsl"
#include "../../Raytracing.hlsl"

Texture2D<float4> _NormalRoughness;
Texture2D<float> _Depth;

RWTexture2D<float3> HitColor;
RWTexture2D<float4> HitResult;

float _RaytracingBias, _RaytracingDistantBias;

RaytracingAccelerationStructure SceneRaytracingAccelerationStructure;

#pragma max_recursion_depth 1

[shader("miss")]
void MissShader(inout RayPayload payload : SV_RayPayload)
{
	payload.packedColor = 0.0;
	payload.hitDistance = 0.0;
}

[shader("raygeneration")]
void RayGeneration()
{
	uint2 position = DispatchRaysIndex().xy;
	float depth = _Depth[position];
	if(depth == 0.0)
		return;
	
	float4 normalRoughness = _NormalRoughness[position];
	float2 u = Noise2D(position);
	float3 N = GBufferNormal(position, _NormalRoughness);
	
	float3 worldPosition = PixelToWorld(float3(position + 0.5, depth));
	float3 V = normalize(-worldPosition);
	
	// We also need to undo the planet curve, since it's not accounted for in the BLAS
	worldPosition = PlanetCurveInverse(worldPosition);
	
	float roughness = max(1e-6, Sq(normalRoughness.a));
	float3 H = SampleGGXIsotropic(V, roughness, u, N);
	float3 L = reflect(-V, H);
	float rcpPdf = rcp(PdfGGXVndfIsotropic(V, roughness, L, N));
	
	RayDesc ray;
	ray.Origin = worldPosition + N * EvaluateRayTracingBias(worldPosition, _Near, _Far, _RaytracingBias * 10, _RaytracingDistantBias * 10);
	ray.Direction = L;
	ray.TMin = 0.0;
	ray.TMax = 1e10f;
	
	RayPayload payload;
	payload.packedColor = 0.0;
	payload.hitDistance = 0.0;
	
	uint flags = RAY_FLAG_CULL_BACK_FACING_TRIANGLES | RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;
	TraceRay(SceneRaytracingAccelerationStructure, flags, 0xFF, 0, 1, 0, ray, payload);
	
	HitColor[position] = R11G11B10ToFloat3(payload.packedColor); // This is a bit redundant since we pack into a float3 anyway.. maybe just keep it packed?
	HitResult[position] = payload.hitDistance ? float4(L * payload.hitDistance, rcpPdf) : 0.0;
}

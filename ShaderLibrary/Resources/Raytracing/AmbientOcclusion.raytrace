#include "../../Common.hlsl"
#include "../../GBuffer.hlsl"
#include "../../Random.hlsl"
#include "../../Samplers.hlsl"
#include "../../Lighting.hlsl"
#include "../../Raytracing.hlsl"

RWTexture2D<float4> HitResult, HitColor;
Texture2D<float> _Depth;
Texture2D<float4> _Normals;
float _Radius, _RawRadius, _AoStrength, _FalloffScale, _FalloffBias, _SampleCount;
float _RaytracingBias, _RaytracingDistantBias;

#pragma max_recursion_depth 10

[shader("miss")]
void MissShaderColor(inout RayPayload payload : SV_RayPayload)
{
	payload.packedColor = 0.0;
	payload.hitDistance = 0.0;
}

[shader("miss")]
void MissShaderHitDistance(inout RayPayloadAmbientOcclusion payload : SV_RayPayload)
{
	payload.hitDistance = 0.0;
}

[shader("raygeneration")]
void RayGeneration()
{
	uint2 position = DispatchRaysIndex().xy;
	float depth = _Depth[position];
	if(depth == 0.0)
		return;
	
	float3 worldPosition = PixelToWorld(float3(position + 0.5, depth));
	float3 V = normalize(-worldPosition);
	float3 N = GBufferNormal(position, _Normals, V);
	
	// We also need to undo the planet curve, since it's not accounted for in the BLAS
	worldPosition = PlanetCurveInverse(worldPosition);
	
	float samples = 8;
	float2 offset1 = Noise2D(position);
	float3 bentN = 0.0;
	float visibilitySum = 0.0;
	
	for(float j = 0.0; j < samples; j++)
	{
		float2 u = frac(Hammersley2dSeq(j, samples) + offset1);
		float3 rayDir = SampleHemisphereCosine(u.x, u.y, N);
	
		RayDesc ray;
		ray.Origin = worldPosition + N * EvaluateRayTracingBias(worldPosition, _Near, _Far, _RaytracingBias * 10, _RaytracingDistantBias * 10);
		ray.Direction = rayDir;
		ray.TMin = 0.0;
		ray.TMax = _RawRadius;
	
		RayPayloadAmbientOcclusion payload;
		payload.hitDistance = 0.0;
		
		uint flags = RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
		TraceRay(SceneRaytracingAccelerationStructure, flags, 0xFF, 1, 2, 1, ray, payload);
		
		float visibility;
		if(!payload.hitDistance)
		{
			visibility = 1.0;
			bentN += rayDir;
		}
		else
		{
			float weight = saturate(Sq(payload.hitDistance) * _FalloffScale + _FalloffBias);
			visibility = lerp(1.0, 0.0, weight);
		}
		
		visibilitySum += visibility;
	}
	
	HitColor[position] = float4(normalize(bentN), visibilitySum / samples);
}

#include "../../Common.hlsl"
#include "../../GBuffer.hlsl"
#include "../../Random.hlsl"
#include "../../Samplers.hlsl"
#include "../../Lighting.hlsl"
#include "../../Raytracing.hlsl"
#include "../../SpaceTransforms.hlsl"

RWTexture2D<float4> HitResult;
float Radius, Falloff;
float _RaytracingBias, _RaytracingDistantBias;

[shader("miss")]
void MissShader(inout RayPayloadVisibility payload : SV_RayPayload)
{
	payload.hitDistance = 0.0;
}

[shader("raygeneration")]
void RayGeneration()
{
	uint2 position = DispatchRaysIndex().xy;
	float depth = Depth[position];
	if (depth == 0.0)
		return;
	
	float3 worldPosition = PixelToWorldPosition(float3(position + 0.5, depth));
	float3 V = normalize(-worldPosition);
	
	float NdotV;
	float3 N = GBufferNormal(position, NormalRoughness, V, NdotV);
	
	
	float2 noise2D = Noise2D(position);
	
	float visibility = 0.0;
	float3 bentNormal = 0.0;
	float weightSum = 0.0;
	
	uint samples = 8;
	for (uint i = 0; i < samples; i++)
	{
		float2 u = Hammersley2dSeq(i, samples);
		u = frac(u + noise2D);
	
		float3 L = SampleHemisphereCosine(u.x, u.y, N);
		
		RayDesc ray;
		ray.Origin = worldPosition + ViewPosition;//+N * EvaluateRayTracingBias(worldPosition, Near, Far, _RaytracingBias, _RaytracingDistantBias);
		ray.Direction = L;
		ray.TMin = 0.001;
		ray.TMax = Radius;
	
		RayPayloadVisibility payload;
	
		uint flags = RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
		TraceRay(SceneRaytracingAccelerationStructure, flags, 0xFF, 0, 1, 0, ray, payload);
		
		if (payload.hitDistance > 0.0)
		{
			// Something was hit
			float start = Radius * Falloff;
			float end = Radius;
			float weight = saturate((end - payload.hitDistance) * rcp(end - start));
			visibility += lerp(1, 0, weight);
			bentNormal += L * (1.0 - weight);
		}
		else
		{
			// No hit
			visibility += 1.0;
			bentNormal += L;
		}
	}
	
	bentNormal /= samples;
	
	float occlusion = visibility / samples;
	HitResult[position] = float4(bentNormal, VisibilityToConeAngle(occlusion));
}

#pragma kernel ClusteredLighting

#include "../Common.hlsl"
#include "../LightingCommon.hlsl"
#include "../Math.hlsl"
#include "../SpaceTransforms.hlsl"

RWStructuredBuffer<uint> LightCounter, LightClusterListWrite;
RWTexture3D<uint2> LightClusterIndicesWrite;

groupshared uint LightIndices[64][64];
float RcpClusterDepth;

bool IntersectSphereAABB(float3 position, float sqRadius, float3 aabbMin, float3 aabbMax)
{
	float x = max(aabbMin.x, min(position.x, aabbMax.x));
	float y = max(aabbMin.y, min(position.y, aabbMax.y));
	float z = max(aabbMin.z, min(position.z, aabbMax.z));
	return SqrLength(float3(x, y, z) - position) < sqRadius;
}

[numthreads(64, 1, 1)]
void ClusteredLighting(uint3 id : SV_DispatchThreadId, uint groupIndex : SV_GroupIndex)
{
	float3 minBounds = 0.0, maxBounds = 0.0;
    
	[unroll]
	for (uint z = 0; z < 2; z++)
	{
		[unroll]
		for (uint y = 0; y < 2; y++)
		{
			[unroll]
			for (uint x = 0; x < 2; x++)
			{
				// TODO: Precompute scale/bias
				float eyeDepth = Near * pow(abs(Far / Near), (id.z + z) * RcpClusterDepth);
                
				float3 positionSS;
				positionSS.x = (id.x + x) * TileSize;
				positionSS.y = (id.y + y) * TileSize;
				positionSS.z = LinearToDeviceDepth(eyeDepth);
                
				float3 positionWS = MultiplyPointProj(PixelToWorld, positionSS).xyz;
                
				if (x == 0 && y == 0 && z == 0)
				{
					minBounds = maxBounds = positionWS;
				}
				else
				{
					minBounds = min(minBounds, positionWS);
					maxBounds = max(maxBounds, positionWS);
				}
			}
		}
	}
    
    // Multiple iterations for > threadCount lights
	uint lightCount = 0;
	for (uint i = 0; i < PointLightCount; i++)
	{
		LightData lightData = PointLights[i];

        // For spotlights, modify their culling sphere
		float3 centerWS = lightData.position;
		if (!IntersectSphereAABB(centerWS, Sq(lightData.range), minBounds, maxBounds))
			continue;

		LightIndices[groupIndex][lightCount++] = i;
	}

	uint lightOffset = 0;
	if (lightCount > 0)
	{
		InterlockedAdd(LightCounter[0], lightCount, lightOffset);

		for (i = 0; i < lightCount; i++)
		{
			LightClusterListWrite[lightOffset + i] = LightIndices[groupIndex][i];
		}
	}
	
	LightClusterIndicesWrite[id] = uint2(lightOffset, lightCount);
}